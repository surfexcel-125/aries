<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Workspace — Aries (8-anchor connectors)</title>
<link rel="stylesheet" href="main.css" />
<style>
:root{
  --accent:#0b74ff; --muted:#6b7280; --panel:#ffffffee; --bg:#ffffff;
  --grid-color:rgba(15,23,42,0.04); --node-shadow:0 10px 28px rgba(15,23,42,0.08);
  --link-color:#0f172a; --link-selected:#ff7a59;
}
html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:var(--bg);}
.site-header{display:flex;align-items:center;gap:10px;padding:10px 14px;border-bottom:1px solid #f1f1f1;background:#fff;position:sticky;top:0;z-index:40;}
.icon-btn{background:transparent;border:0;font-size:18px;cursor:pointer;padding:6px;border-radius:999px;}
.header-title{font-weight:700;font-size:0.98rem}
.btn{padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:600;font-size:0.9rem}
.btn.primary{background:var(--accent);color:#fff}
.btn.ghost{background:transparent;color:var(--muted);border:1px solid #e5e7eb}
.header-right{margin-left:auto;display:flex;align-items:center;gap:8px}
.zoom-ind{padding:6px 8px;border-radius:8px;border:1px solid #e5e7eb;background:#fff;font-weight:600;font-size:0.85rem}

.viewport{position:relative;height:calc(100vh - 56px);overflow:hidden;background:var(--bg)}
.pan-layer{position:absolute;inset:0;touch-action:none}
.board{position:absolute;left:50%;top:50%;transform-origin:0 0;will-change:transform}
.canvas{position:relative;width:2000px;height:1400px;background:transparent;border-radius:0;margin:0;overflow:visible}

/* nodes */
.node{position:absolute;min-width:160px;max-width:420px;padding:12px 14px;border-radius:10px;background:#fff;border:1px solid rgba(0,0,0,0.06);box-shadow:var(--node-shadow);cursor:grab;user-select:none;z-index:8}
.node:active{cursor:grabbing}
.node .title{margin:0 0 6px;font-weight:700;font-size:0.98rem}
.node .body{margin:0;font-size:0.9rem;color:var(--muted);white-space:pre-wrap}
.node .mini{position:absolute;right:8px;top:8px;display:flex;gap:6px}
.node-shape-soft{border-radius:16px}
.node-shape-pill{border-radius:999px}
.node-shape-outline{background:transparent;border-style:dashed}

/* floating tools */
.floating-tools{position:fixed;left:14px;top:62px;width:260px;padding:10px;background:var(--panel);border-radius:12px;box-shadow:0 16px 40px rgba(15,23,42,0.18);backdrop-filter:blur(8px);z-index:50;opacity:0;pointer-events:none;transform:translateY(-8px);transition:opacity .16s,transform .16s}
.floating-tools.open{opacity:1;pointer-events:auto;transform:none}
.tool-row{display:flex;flex-wrap:wrap;gap:6px}
.tool-btn{padding:6px 8px;border-radius:8px;background:#f3f4f6;border:0;font-size:0.85rem;cursor:pointer}

/* bottom zoom */
.bottom-zoom{position:fixed;left:16px;bottom:16px;z-index:45;display:flex;gap:6px}
.zoom-btn{width:34px;height:34px;border-radius:999px;border:1px solid #e5e7eb;background:#fff;font-size:18px;cursor:pointer;box-shadow:0 10px 30px rgba(15,23,42,0.16)}

/* grid panel */
.grid-panel{position:fixed;right:16px;bottom:16px;z-index:45;padding:8px 10px;border-radius:12px;background:#fff;box-shadow:0 10px 30px rgba(15,23,42,0.12);font-size:0.83rem;color:var(--muted);display:flex;gap:8px;align-items:center}
.grid-panel input[type="number"]{width:60px;padding:4px 6px;border-radius:8px;border:1px solid #e5e7eb;font-size:0.8rem}

/* modal */
.modal-backdrop{position:fixed;inset:0;display:none;justify-content:center;align-items:center;background:rgba(0,0,0,0.38);z-index:1200}
.modal{width:380px;max-width:94vw;background:var(--panel);border-radius:12px;padding:16px;box-shadow:0 18px 40px rgba(15,23,42,0.3)}
.field{margin:8px 0;display:flex;flex-direction:column;gap:4px}
.field input[type="text"],.field textarea,.field select,.field input[type="color"]{padding:8px;border-radius:8px;border:1px solid #e5e7eb;font-size:0.9rem}

/* tutorial */
.tutorial-backdrop{position:fixed;inset:0;background:linear-gradient(180deg,rgba(15,23,42,0.7),rgba(15,23,42,0.7));color:#fff;z-index:1300;display:none}
.tutorial-card{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);max-width:900px;padding:24px}
.tutorial-step{background:rgba(15,23,42,0.4);border-radius:14px;padding:16px;border:1px solid rgba(255,255,255,0.12)}
.tutorial-footer{margin-top:10px;display:flex;justify-content:space-between;align-items:center;gap:8px;font-size:0.85rem}
.tutorial-btn{padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-size:0.9rem}

/* svg link styles + handles */
svg.link-layer{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:6}
.link-line{stroke:var(--link-color);stroke-width:2;stroke-linecap:round;fill:none;pointer-events:stroke}
.link-line.selected{stroke:var(--link-selected);stroke-width:3}
.handle{fill:#fff;stroke:#0b74ff;stroke-width:2;cursor:pointer;pointer-events:auto}
.hidden{display:none}

/* debug anchors (hidden by default) */
.anchor-debug{position:absolute;width:8px;height:8px;border-radius:50%;background:rgba(11,116,255,0.9);transform:translate(-50%,-50%);z-index:11;display:none}

@media (max-width:900px){.canvas{width:1400px;height:1000px}.floating-tools{width:210px}}
</style>
</head>
<body>
  <header class="site-header">
    <button id="menuIcon" class="icon-btn" aria-label="Tools menu">☰</button>
    <button id="backToProjects" class="btn ghost">Projects</button>
    <div class="header-title">Workspace</div>
    <div class="header-right">
      <div id="zoomIndicator" class="zoom-ind">100%</div>
      <button id="saveBoard" class="btn primary">Save</button>
      <button id="exportBtn" class="btn ghost">Export</button>
      <label for="importFile" class="btn ghost" style="cursor:pointer;">Import</label>
      <input id="importFile" type="file" accept="application/json" style="display:none;">
    </div>
  </header>

  <aside id="floatingTools" class="floating-tools" aria-hidden="true">
    <h4>Tools</h4>
    <div class="tool-row">
      <button id="toolAddNode" class="tool-btn">+ Node</button>
      <button id="toolConnector" class="tool-btn">Connector</button>
      <button id="toolDeleteLink" class="tool-btn" disabled>Delete Link</button>
      <button id="toolDeleteNode" class="tool-btn" disabled>Delete Node</button>
    </div>
    <div style="margin-top:10px;font-size:0.9rem;color:var(--muted)">Selected link: <span id="selectedLinkLabel">none</span></div>
  </aside>

  <main class="viewport">
    <div id="panLayer" class="pan-layer" tabindex="0">
      <div id="board" class="board">
        <div id="canvas" class="canvas"></div>
        <svg id="svg" class="link-layer" xmlns="http://www.w3.org/2000/svg"></svg>
      </div>
    </div>
  </main>

  <div class="bottom-zoom">
    <button id="zoomOutCorner" class="zoom-btn" aria-label="Zoom out">−</button>
    <button id="zoomInCorner" class="zoom-btn" aria-label="Zoom in">+</button>
  </div>

  <div class="grid-panel">
    <label><input id="showGrid" type="checkbox" checked> Grid</label>
    <label>Size <input id="gridSize" type="number" value="20" min="5" max="200"></label>
    <button id="centerBtn" class="tutorial-btn" style="background:#f3f4f6;">Center</button>
  </div>

  <div id="modal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <h3>Block settings</h3>
      <div class="field"><label>Title</label><input id="modalTitle" type="text"></div>
      <div class="field"><label>Body</label><textarea id="modalBody" rows="4"></textarea></div>
      <div class="field"><label>Color</label><input id="modalColor" type="color" value="#ffffff"></div>
      <div class="field"><label>Shape</label>
        <select id="modalShape"><option value="card">Card</option><option value="soft">Soft</option><option value="pill">Pill</option><option value="outline">Outline</option></select>
      </div>
      <div class="modal-actions" style="display:flex;justify-content:space-between;margin-top:12px">
        <button id="deleteBlock" class="btn ghost">Delete</button>
        <div style="display:flex;gap:8px"><button id="cancelModal" class="btn ghost">Cancel</button><button id="saveModal" class="btn primary">Save</button></div>
      </div>
    </div>
  </div>

  <div id="tutorial" class="tutorial-backdrop" aria-hidden="true">
    <div class="tutorial-card">
      <div id="tutorialStep" class="tutorial-step"></div>
      <div class="tutorial-footer">
        <div id="tutorialProgress"></div>
        <div style="display:flex;gap:8px">
          <button id="tutorialPrev" class="tutorial-btn" style="background:transparent;color:#fff;border:1px solid rgba(255,255,255,0.4)">Prev</button>
          <button id="tutorialNext" class="tutorial-btn" style="background:var(--accent);color:#fff">Next</button>
          <button id="tutorialClose" class="tutorial-btn" style="background:transparent;color:#fff;border:1px solid rgba(255,255,255,0.4)">Close</button>
        </div>
      </div>
    </div>
  </div>

<script src="app.js" defer></script>
<script>
(function(){
  /* Elements */
  const canvas = document.getElementById('canvas');
  const board = document.getElementById('board');
  const panLayer = document.getElementById('panLayer');
  const svg = document.getElementById('svg');

  const menuIcon = document.getElementById('menuIcon');
  const floatingTools = document.getElementById('floatingTools');
  const toolAddNode = document.getElementById('toolAddNode');
  const toolConnector = document.getElementById('toolConnector');
  const toolDeleteLink = document.getElementById('toolDeleteLink');
  const toolDeleteNode = document.getElementById('toolDeleteNode');
  const selectedLinkLabel = document.getElementById('selectedLinkLabel');

  const backToProjects = document.getElementById('backToProjects');
  const saveBoardBtn = document.getElementById('saveBoard');
  const exportBtn = document.getElementById('exportBtn');
  const importFile = document.getElementById('importFile');
  const zoomIndicator = document.getElementById('zoomIndicator');
  const zoomInCorner = document.getElementById('zoomInCorner');
  const zoomOutCorner = document.getElementById('zoomOutCorner');

  const showGrid = document.getElementById('showGrid');
  const gridSizeInput = document.getElementById('gridSize');
  const centerBtn = document.getElementById('centerBtn');

  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalBody = document.getElementById('modalBody');
  const modalColor = document.getElementById('modalColor');
  const modalShape = document.getElementById('modalShape');
  const saveModalBtn = document.getElementById('saveModal');
  const cancelModalBtn = document.getElementById('cancelModal');
  const deleteBlockBtn = document.getElementById('deleteBlock');

  const tutorial = document.getElementById('tutorial');
  const tutorialStep = document.getElementById('tutorialStep');
  const tutorialProgress = document.getElementById('tutorialProgress');
  const tutorialPrev = document.getElementById('tutorialPrev');
  const tutorialNext = document.getElementById('tutorialNext');
  const tutorialClose = document.getElementById('tutorialClose');

  /* Storage & model */
  function getQueryParam(k){ return new URLSearchParams(location.search).get(k); }
  const projectId = getQueryParam('id') || 'demo';
  const storageKey = 'aries_anchors_v1_' + projectId;
  const tutorialKey = 'aries_tutorial_' + projectId;

  let model = { nodes: [], links: [] }; // link: {id, from, to, fromAnchor, toAnchor, points?}
  let selectedNodeId = null;
  let selectedLinkId = null;

  /* Transform */
  let scale = 1, pan = {x:0,y:0};
  const MIN_SCALE = 0.35, MAX_SCALE = 2.6, SCALE_STEP = 0.12;

  /* Drag/Pinch */
  let draggingId = null, dragOffset = {x:0,y:0};
  let isPanning = false, panStart = {x:0,y:0};
  const pointerMap = new Map(); let pinchState = null;

  /* Connect mode */
  let connectMode = false, connectFrom = null;

  /* Snap/grid */
  let snapOn = true, gridSize = Number(gridSizeInput.value) || 20;

  /* helpers */
  function uid(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,6); }
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  function flash(msg){ const el=document.createElement('div'); el.textContent=msg; Object.assign(el.style,{position:'fixed',right:'20px',bottom:'24px',background:'#0b74ff',color:'#fff',padding:'8px 12px',borderRadius:'8px',zIndex:1500}); document.body.appendChild(el); setTimeout(()=>el.remove(),1200); }
  function pageToModel(x,y){ const rect = canvas.getBoundingClientRect(); return { x:(x-rect.left)/scale, y:(y-rect.top)/scale }; }
  function getNodeBounds(n){ return { x: n.x, y: n.y, w: n.w || 230, h: n.h || 120 }; }
  // compute 8 anchors for node: top[0..2], bottom[3..5], left[6], right[7]
  function computeAnchors(n){
    const b = getNodeBounds(n);
    const topYs = b.y;
    const bottomYs = b.y + b.h;
    const xs = [ b.x + b.w*0.25, b.x + b.w*0.5, b.x + b.w*0.75 ];
    const anchors = [];
    // top three
    anchors.push({ x: xs[0], y: topYs, side: 'top' });
    anchors.push({ x: xs[1], y: topYs, side: 'top' });
    anchors.push({ x: xs[2], y: topYs, side: 'top' });
    // bottom three
    anchors.push({ x: xs[0], y: bottomYs, side: 'bottom' });
    anchors.push({ x: xs[1], y: bottomYs, side: 'bottom' });
    anchors.push({ x: xs[2], y: bottomYs, side: 'bottom' });
    // left center
    anchors.push({ x: b.x, y: b.y + b.h/2, side: 'left' });
    // right center
    anchors.push({ x: b.x + b.w, y: b.y + b.h/2, side: 'right' });
    return anchors;
  }

  /* Persistence */
  function loadModel(){ try{ const raw = localStorage.getItem(storageKey); model = raw ? JSON.parse(raw) : {nodes:[],links:[]}; }catch(e){ model={nodes:[],links:[]}; } }
  function saveModel(){ try{ localStorage.setItem(storageKey, JSON.stringify(model)); }catch(e){} flash('Saved'); }

  /* Grid */
  function updateGrid(){ if(!showGrid.checked){ canvas.style.backgroundImage='none'; return; } const size = gridSize; canvas.style.backgroundImage = `linear-gradient(to right, var(--grid-color) 1px, transparent 1px), linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px)`; canvas.style.backgroundSize = size+'px '+size+'px'; }

  /* Transform */
  function applyTransform(){
    const rect = canvas.getBoundingClientRect();
    const tx = -rect.width/2 + pan.x;
    const ty = -rect.height/2 + pan.y;
    board.style.transform = `translate(${tx}px,${ty}px) scale(${scale})`;
    zoomIndicator.textContent = Math.round(scale*100)+'%';
    renderLinks();
  }
  function zoomAt(newScale, clientX, clientY){
    const before = pageToModel(clientX, clientY);
    scale = clamp(newScale, MIN_SCALE, MAX_SCALE);
    applyTransform();
    const after = pageToModel(clientX, clientY);
    pan.x += (after.x - before.x) * scale;
    pan.y += (after.y - before.y) * scale;
    applyTransform();
  }

  /* Nodes */
  function createNodeDOM(n){
    const el = document.createElement('div');
    el.className = 'node';
    el.dataset.id = n.id;
    el.style.left = n.x+'px'; el.style.top = n.y+'px';
    el.style.width = (n.w||230)+'px'; el.style.background = n.color||'#fff';
    el.innerHTML = `<div class="mini"><button class="mini-edit" style="background:transparent;border:0;font-size:14px;cursor:pointer">✎</button></div><div class="title"></div><div class="body"></div>`;
    el.addEventListener('pointerdown', onNodePointerDown);
    el.addEventListener('click', (e)=>{ e.stopPropagation(); selectNode(n.id); if(connectMode) nodeClickForConnect(n.id); });
    el.addEventListener('dblclick', ()=> openModal(n.id));
    el.querySelector('.mini-edit').addEventListener('click', ev=>{ ev.stopPropagation(); openModal(n.id); });
    return el;
  }

  function renderNodes(){
    updateGrid();
    const ids = new Set(model.nodes.map(n=>n.id));
    Array.from(canvas.querySelectorAll('.node')).forEach(el=>{ if(!ids.has(el.dataset.id)) el.remove(); });
    model.nodes.forEach(n=>{
      let el = canvas.querySelector('.node[data-id="'+n.id+'"]');
      if(!el){ el = createNodeDOM(n); canvas.appendChild(el); }
      el.style.left = n.x+'px'; el.style.top = n.y+'px'; el.style.width = (n.w||230)+'px'; el.style.background = n.color||'#fff';
      el.classList.remove('node-shape-soft','node-shape-pill','node-shape-outline');
      if(n.shape==='soft') el.classList.add('node-shape-soft');
      if(n.shape==='pill') el.classList.add('node-shape-pill');
      if(n.shape==='outline'){ el.classList.add('node-shape-outline'); el.style.background='transparent'; }
      el.querySelector('.title').textContent = n.title||'Untitled';
      el.querySelector('.body').textContent = n.body||'';
      el.style.outline = (selectedNodeId === n.id) ? '3px solid rgba(11,116,255,0.12)' : 'none';
    });
    renderLinks();
  }

  function addNodeAt(x,y){
    const id = uid();
    const node = { id, x:Math.max(40,x), y:Math.max(40,y), w:230, h:120, title:'New block', body:'Double-click or click ✎ to edit', color:'#fffdf5', shape:'card' };
    model.nodes.push(node); saveModel(); renderNodes(); openModal(id);
  }

  /* Drag node */
  function onNodePointerDown(e){
    e.stopPropagation();
    const el = e.currentTarget; const id = el.dataset.id;
    draggingId = id;
    const node = model.nodes.find(n=>n.id===id);
    const pos = pageToModel(e.clientX,e.clientY);
    dragOffset.x = pos.x - (node.x||0);
    dragOffset.y = pos.y - (node.y||0);
    el.setPointerCapture(e.pointerId);
    el.addEventListener('pointermove', onNodePointerMove);
    el.addEventListener('pointerup', onNodePointerUp);
  }
  function onNodePointerMove(e){
    if(!draggingId) return;
    const pos = pageToModel(e.clientX,e.clientY);
    let x = pos.x - dragOffset.x; let y = pos.y - dragOffset.y;
    if(snapOn){
      const gs = gridSize; const snapX = Math.round(x/gs)*gs; const snapY = Math.round(y/gs)*gs;
      x = x + (snapX - x)*0.35; y = y + (snapY - y)*0.35;
    }
    const node = model.nodes.find(n=>n.id===draggingId);
    if(!node) return;
    node.x = Math.max(0, Math.round(x)); node.y = Math.max(0, Math.round(y));
    renderNodes();
  }
  function onNodePointerUp(e){
    const id = e.currentTarget.dataset.id;
    const node = model.nodes.find(n=>n.id===id);
    if(node && snapOn){ const gs = gridSize; node.x = Math.round(node.x/gs)*gs; node.y = Math.round(node.y/gs)*gs; }
    // automatic linking on drop via anchor distances
    autoLinkOnDrop(node);
    draggingId = null;
    try{ e.currentTarget.removeEventListener('pointermove', onNodePointerMove); e.currentTarget.removeEventListener('pointerup', onNodePointerUp); }catch(err){}
    saveModel(); renderNodes();
  }

  /* Auto-link on drop by nearest anchors */
  function anchorDistance(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }
  function autoLinkOnDrop(node){
    if(!node) return;
    const threshold = 12; // px
    const anchorsA = computeAnchors(node);
    model.nodes.forEach(other=>{
      if(other.id === node.id) return;
      const anchorsB = computeAnchors(other);
      // find closest pair
      let best = Infinity, bestPair = null;
      anchorsA.forEach((pa,i)=>{
        anchorsB.forEach((pb,j)=>{
          const d = anchorDistance(pa,pb);
          if(d < best){ best = d; bestPair = { aIndex:i, bIndex:j, d }; }
        });
      });
      if(bestPair && bestPair.d <= threshold){
        // create link from node -> other using the chosen anchors
        const exists = model.links.some(l => l.from === node.id && l.to === other.id && l.fromAnchor === bestPair.aIndex && l.toAnchor === bestPair.bIndex);
        if(!exists){
          model.links.push({ id: uid(), from: node.id, to: other.id, fromAnchor: bestPair.aIndex, toAnchor: bestPair.bIndex, points: null });
        }
      }
    });
  }

  /* Pan/zoom events */
  panLayer.addEventListener('pointerdown', e=>{
    if(e.target.closest('.node')) return;
    panLayer.setPointerCapture(e.pointerId);
    isPanning = true; panStart.x = e.clientX - pan.x; panStart.y = e.clientY - pan.y;
    panLayer.addEventListener('pointermove', onPanMove); panLayer.addEventListener('pointerup', onPanEnd);
  });
  function onPanMove(e){ if(!isPanning) return; pan.x = e.clientX - panStart.x; pan.y = e.clientY - panStart.y; applyTransform(); }
  function onPanEnd(e){ isPanning = false; panLayer.removeEventListener('pointermove', onPanMove); panLayer.removeEventListener('pointerup', onPanEnd); saveModel(); }

  panLayer.addEventListener('wheel', e=>{ e.preventDefault(); const delta = e.deltaY > 0 ? -SCALE_STEP : SCALE_STEP; const newScale = scale + delta; zoomAt(newScale,e.clientX,e.clientY); }, { passive:false });

  // pinch to zoom
  panLayer.addEventListener('pointerdown', e=>{ pointerMap.set(e.pointerId,e); if(pointerMap.size===2){ const arr=Array.from(pointerMap.values()); pinchState={ dist: Math.hypot(arr[0].clientX-arr[1].clientX, arr[0].clientY-arr[1].clientY), scale:scale, center:{x:(arr[0].clientX+arr[1].clientX)/2,y:(arr[0].clientY+arr[1].clientY)/2} }; } e.target.setPointerCapture(e.pointerId); });
  panLayer.addEventListener('pointermove', e=>{ if(!pointerMap.has(e.pointerId)) return; pointerMap.set(e.pointerId,e); if(pinchState && pointerMap.size===2){ const arr=Array.from(pointerMap.values()); const dist=Math.hypot(arr[0].clientX-arr[1].clientX,arr[0].clientY-arr[1].clientY); const factor = dist / pinchState.dist; const newScale = clamp(pinchState.scale * factor, MIN_SCALE, MAX_SCALE); zoomAt(newScale, pinchState.center.x, pinchState.center.y); } });
  ['pointerup','pointercancel'].forEach(t=>panLayer.addEventListener(t,e=>{ pointerMap.delete(e.pointerId); if(pointerMap.size<2) pinchState=null; }));

  /* Links: render, selection, handles */
  function renderLinks(){
    svg.innerHTML = '';
    // defs arrow
    const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
    defs.innerHTML = `<marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="${getComputedStyle(document.documentElement).getPropertyValue('--link-color')||'#0f172a'}"></path></marker>`;
    svg.appendChild(defs);

    model.links.forEach(link=>{
      // compute anchor positions (model coords) for endpoint anchors
      const fromNode = model.nodes.find(n=>n.id===link.from);
      const toNode = model.nodes.find(n=>n.id===link.to);
      if(!fromNode || !toNode) return;
      const aFrom = computeAnchors(fromNode)[ link.fromAnchor ?? 3 /* fallback */ ];
      const aTo   = computeAnchors(toNode)[ link.toAnchor ?? 4 /* fallback */ ];
      // if link has points -> draw polyline else just straight line between anchors
      if(link.points && link.points.length){
        // build point list: start anchor, points..., end anchor
        const pts = [ {x: aFrom.x, y: aFrom.y} ].concat(link.points).concat([ {x: aTo.x, y: aTo.y} ]);
        const scaled = pts.map(p => `${p.x*scale},${p.y*scale}`).join(' ');
        const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
        poly.setAttribute('points', scaled);
        poly.classList.add('link-line');
        poly.dataset.id = link.id;
        poly.setAttribute('fill','none');
        poly.setAttribute('stroke', selectedLinkId===link.id ? getComputedStyle(document.documentElement).getPropertyValue('--link-selected') : getComputedStyle(document.documentElement).getPropertyValue('--link-color'));
        poly.setAttribute('stroke-width', Math.max(2,2*scale));
        poly.style.pointerEvents = 'stroke';
        poly.addEventListener('click', e=>{ e.stopPropagation(); selectLink(link.id); });
        poly.addEventListener('dblclick', e=>{ e.stopPropagation(); insertHandleAt(link,e); });
        svg.appendChild(poly);
        // add handle circles for internal points
        (link.points||[]).forEach((p,i)=>{
          const cx = p.x*scale, cy = p.y*scale;
          const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
          c.setAttribute('cx',cx); c.setAttribute('cy',cy); c.setAttribute('r',8);
          c.classList.add('handle'); c.dataset.linkId = link.id; c.dataset.handleIndex = i;
          enableSvgHandleDrag(c, link, i);
          svg.appendChild(c);
        });
        // add arrowhead at end: use small triangle path because marker on polyline may be inconsistent across browsers; append a small marker line
        // create a small invisible line for marker
        const last = pts[pts.length-1], prev = pts[pts.length-2];
        const arrowLine = document.createElementNS('http://www.w3.org/2000/svg','line');
        arrowLine.setAttribute('x1', prev.x*scale); arrowLine.setAttribute('y1', prev.y*scale);
        arrowLine.setAttribute('x2', last.x*scale); arrowLine.setAttribute('y2', last.y*scale);
        arrowLine.setAttribute('stroke','transparent'); arrowLine.setAttribute('marker-end','url(#arrow)');
        svg.appendChild(arrowLine);
      } else {
        const fx = aFrom.x*scale, fy = aFrom.y*scale;
        const tx = aTo.x*scale, ty = aTo.y*scale;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1', fx); line.setAttribute('y1', fy); line.setAttribute('x2', tx); line.setAttribute('y2', ty);
        line.setAttribute('stroke', selectedLinkId===link.id ? getComputedStyle(document.documentElement).getPropertyValue('--link-selected') : getComputedStyle(document.documentElement).getPropertyValue('--link-color'));
        line.setAttribute('stroke-width', Math.max(2,2*scale));
        line.setAttribute('marker-end','url(#arrow)');
        line.classList.add('link-line');
        line.dataset.id = link.id;
        line.style.pointerEvents = 'stroke';
        line.addEventListener('click', e=>{ e.stopPropagation(); selectLink(link.id); });
        line.addEventListener('dblclick', e=>{ e.stopPropagation(); // convert straight to polyline by inserting midpoint
          const mx = (aFrom.x + aTo.x)/2; const my = (aFrom.y + aTo.y)/2;
          link.points = link.points || []; link.points.push({x:mx,y:my}); saveModel(); renderLinks();
        });
        svg.appendChild(line);
      }
    });
  }

  /* Polyline handle interactions */
  function enableSvgHandleDrag(circleEl, link, index){
    let dragging = false;
    circleEl.addEventListener('pointerdown', (e)=>{
      e.stopPropagation(); dragging = true; circleEl.setPointerCapture(e.pointerId);
      const onMove = (ev)=>{
        const rect = canvas.getBoundingClientRect();
        const mx = (ev.clientX - rect.left) / scale;
        const my = (ev.clientY - rect.top) / scale;
        link.points[index] = { x: mx, y: my }; renderLinks();
      };
      const onUp = (ev)=>{
        dragging = false; circleEl.releasePointerCapture(ev.pointerId); document.removeEventListener('pointermove', onMove); document.removeEventListener('pointerup', onUp); saveModel();
      };
      document.addEventListener('pointermove', onMove);
      document.addEventListener('pointerup', onUp);
    });
    circleEl.addEventListener('dblclick', e=>{ e.stopPropagation(); link.points.splice(index,1); if(link.points.length===0) link.points=null; saveModel(); renderLinks(); });
  }

  /* Insert handle on polyline double-click */
  function insertHandleAt(link, e){
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) / scale;
    const my = (e.clientY - rect.top) / scale;
    link.points = link.points || [];
    // insert at nearest segment by distance to segment midpoints
    let bestIdx = 0, bestD = Infinity;
    for(let i=0;i<=link.points.length;i++){
      const a = (i===0) ? computeAnchors(model.nodes.find(n=>n.id===link.from))[link.fromAnchor] : link.points[i-1];
      const b = (i===link.points.length) ? computeAnchors(model.nodes.find(n=>n.id===link.to))[link.toAnchor] : link.points[i];
      // compute distance from (mx,my) to segment ab
      const d = pointToSegmentDistance({x:mx,y:my}, a, b);
      if(d < bestD){ bestD = d; bestIdx = i; }
    }
    link.points.splice(bestIdx, 0, { x: mx, y: my });
    saveModel(); renderLinks();
  }
  function pointToSegmentDistance(p,a,b){
    const vx = b.x - a.x, vy = b.y - a.y;
    const wx = p.x - a.x, wy = p.y - a.y;
    const c1 = vx*wx + vy*wy;
    if(c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
    const c2 = vx*vx + vy*vy;
    if(c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
    const t = c1 / c2;
    const projx = a.x + t*vx, projy = a.y + t*vy;
    return Math.hypot(p.x - projx, p.y - projy);
  }

  /* Selection & delete */
  function selectLink(id){
    selectedLinkId = id; selectedLinkLabel.textContent = id || 'none'; toolDeleteLink.disabled = !id;
    selectedNodeId = null; toolDeleteNode.disabled = true; renderNodes(); renderLinks();
  }
  function selectNode(id){
    selectedNodeId = id; selectedLinkId = null; toolDeleteNode.disabled = !id; toolDeleteLink.disabled = true; selectedLinkLabel.textContent = 'none'; renderNodes(); renderLinks();
  }

  toolDeleteNode.addEventListener('click', ()=>{
    if(!selectedNodeId) return;
    if(!confirm('Delete selected block?')) return;
    model.links = model.links.filter(l => l.from !== selectedNodeId && l.to !== selectedNodeId);
    model.nodes = model.nodes.filter(n => n.id !== selectedNodeId);
    selectedNodeId = null; toolDeleteNode.disabled = true; saveModel(); renderNodes();
  });

  toolDeleteLink.addEventListener('click', ()=>{
    if(!selectedLinkId) return;
    if(!confirm('Delete selected link?')) return;
    model.links = model.links.filter(l => l.id !== selectedLinkId);
    selectedLinkId = null; selectedLinkLabel.textContent = 'none'; toolDeleteLink.disabled = true; saveModel(); renderLinks();
  });

  // keyboard delete/backspace
  window.addEventListener('keydown', (e)=>{
    if(e.key === 'Delete' || e.key === 'Backspace'){
      if(selectedNodeId){
        model.links = model.links.filter(l => l.from !== selectedNodeId && l.to !== selectedNodeId);
        model.nodes = model.nodes.filter(n => n.id !== selectedNodeId);
        selectedNodeId = null; toolDeleteNode.disabled = true; saveModel(); renderNodes();
      } else if(selectedLinkId){
        model.links = model.links.filter(l => l.id !== selectedLinkId);
        selectedLinkId = null; selectedLinkLabel.textContent = 'none'; toolDeleteLink.disabled = true; saveModel(); renderLinks();
      }
    }
  });

  /* Connector tool flow */
  toolConnector.addEventListener('click', ()=> {
    connectMode = !connectMode; connectFrom = null;
    toolConnector.style.background = connectMode ? '#fdecea' : '';
    toolConnector.textContent = connectMode ? 'Connector (active)' : 'Connector';
    if(connectMode) flash('Connector active — click source then target');
  });

  function nodeClickForConnect(id){
    if(!connectMode) return;
    if(!connectFrom){ connectFrom = id; highlightNode(connectFrom,true); flash('Source selected — click target'); return; }
    if(connectFrom === id){ highlightNode(connectFrom,false); connectFrom = null; return; }
    // choose nearest anchor pair between nodes
    const fromNode = model.nodes.find(n=>n.id===connectFrom);
    const toNode = model.nodes.find(n=>n.id===id);
    if(!fromNode || !toNode){ connectFrom = null; setConnectMode(false); return; }
    const anchorsFrom = computeAnchors(fromNode);
    const anchorsTo = computeAnchors(toNode);
    let best = Infinity, bestPair = null;
    anchorsFrom.forEach((af,i)=>{ anchorsTo.forEach((at,j)=>{ const d = Math.hypot(af.x - at.x, af.y - at.y); if(d < best){ best = d; bestPair = {i,j}; } }); });
    if(bestPair){
      model.links.push({ id: uid(), from: connectFrom, to: id, fromAnchor: bestPair.i, toAnchor: bestPair.j, points: null });
      saveModel(); renderLinks();
    }
    highlightNode(connectFrom,false); connectFrom = null; setConnectMode(false);
  }
  function highlightNode(id,on){ const el = canvas.querySelector('.node[data-id="'+id+'"]'); if(!el) return; el.style.outline = on ? '3px solid rgba(11,116,255,0.12)' : 'none'; }
  function setConnectMode(on){ connectMode = !!on; connectFrom = null; toolConnector.style.background = connectMode ? '#fdecea' : ''; toolConnector.textContent = connectMode ? 'Connector (active)' : 'Connector'; }

  /* Modal editing */
  function openModal(id){
    selectedNodeId = id;
    const node = model.nodes.find(n=>n.id===id);
    if(!node) return;
    modalTitle.value = node.title || '';
    modalBody.value = node.body || '';
    modalColor.value = node.color || '#ffffff';
    modalShape.value = node.shape || 'card';
    modal.style.display = 'flex'; modal.setAttribute('aria-hidden','false'); modalTitle.focus();
    selectNode(id);
  }
  function closeModal(){ modal.style.display='none'; modal.setAttribute('aria-hidden','true'); }
  saveModalBtn.addEventListener('click', ()=>{ if(!selectedNodeId) return closeModal(); const node = model.nodes.find(n=>n.id===selectedNodeId); if(!node) return closeModal(); node.title = modalTitle.value.trim(); node.body = modalBody.value.trim(); node.color = modalColor.value; node.shape = modalShape.value; saveModel(); renderNodes(); closeModal(); });
  cancelModalBtn.addEventListener('click', closeModal);
  deleteBlockBtn.addEventListener('click', ()=>{ if(!selectedNodeId) return closeModal(); if(!confirm('Delete this block?')) return; model.links = model.links.filter(l => l.from !== selectedNodeId && l.to !== selectedNodeId); model.nodes = model.nodes.filter(n => n.id !== selectedNodeId); saveModel(); renderNodes(); closeModal(); });

  /* UI actions */
  function handleAddNode(){ const rect = canvas.getBoundingClientRect(); const pos = pageToModel(rect.left + rect.width/2, rect.top + rect.height/2); addNodeAt(pos.x-100,pos.y-40); }
  document.getElementById('addNode')?.addEventListener('click', handleAddNode);
  toolAddNode.addEventListener('click', handleAddNode);

  zoomInCorner.addEventListener('click', ()=> zoomAt(scale + SCALE_STEP, window.innerWidth/2, window.innerHeight/2));
  zoomOutCorner.addEventListener('click', ()=> zoomAt(scale - SCALE_STEP, window.innerWidth/2, window.innerHeight/2));

  saveBoardBtn.addEventListener('click', ()=> saveModel());
  backToProjects.addEventListener('click', ()=> { saveModel(); window.location.href = 'projects.html'; });

  exportBtn.addEventListener('click', ()=>{ const data = JSON.stringify(model,null,2); const blob = new Blob([data],{type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = (projectId||'board') + '.board.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });
  importFile.addEventListener('change', e=>{ const f=e.target.files[0]; if(!f) return; const r=new FileReader(); r.onload=function(){ try{ const parsed=JSON.parse(r.result); if(parsed && parsed.nodes){ model=parsed; saveModel(); renderNodes(); flash('Imported'); } else alert('Invalid file'); } catch(err){ alert('Invalid JSON'); } }; r.readAsText(f); });

  showGrid.addEventListener('change', ()=> updateGrid());
  gridSizeInput.addEventListener('change', ()=>{ gridSize = clamp(Number(gridSizeInput.value)||20,5,200); updateGrid(); });
  centerBtn.addEventListener('click', ()=> { pan={x:0,y:0}; scale=1; applyTransform(); });

  menuIcon.addEventListener('click', ()=> { const isOpen = floatingTools.classList.toggle('open'); floatingTools.setAttribute('aria-hidden', isOpen ? 'false':'true'); });

  /* Canvas click deselect */
  canvas.addEventListener('click', (e)=>{ selectedNodeId = null; selectedLinkId = null; toolDeleteNode.disabled = true; toolDeleteLink.disabled = true; selectedLinkLabel.textContent = 'none'; renderNodes(); renderLinks(); });

  /* Tutorial */
  const steps = [
    {title:'Welcome',text:'Add nodes, drag to move, scroll to zoom. Use Connector to link or drop nodes near each other to auto-link.'},
    {title:'Edit',text:'Double-click a block or click ✎ to open settings. Change color or shape.'},
    {title:'Bend connectors',text:'Double-click a connector to add a handle. Drag handles to bend the line.'}
  ];
  let tutorialIndex = 0;
  function showTutorial(i){ tutorial.style.display='block'; tutorial.setAttribute('aria-hidden','false'); tutorialIndex = clamp(i,0,steps.length-1); const s = steps[tutorialIndex]; tutorialStep.innerHTML = `<h2 style="margin:0 0 6px">${s.title}</h2><div style="opacity:0.95">${s.text}</div>`; tutorialProgress.textContent = `Step ${tutorialIndex+1} / ${steps.length}`; tutorialPrev.style.visibility = tutorialIndex===0 ? 'hidden':'visible'; tutorialNext.textContent = tutorialIndex===steps.length-1 ? 'Finish':'Next'; }
  tutorialNext.addEventListener('click', ()=> { if(tutorialIndex===steps.length-1) closeTutorial(); else showTutorial(tutorialIndex+1); });
  tutorialPrev.addEventListener('click', ()=> showTutorial(tutorialIndex-1));
  tutorialClose.addEventListener('click', closeTutorial);
  function closeTutorial(){ tutorial.style.display='none'; tutorial.setAttribute('aria-hidden','true'); localStorage.setItem(tutorialKey,'seen'); }

  /* Bootstrap */
  loadModel();
  if(!model.nodes.length){
    model.nodes.push({ id: uid(), x:120, y:120, w:260, h:120, title:'Start', body:'Drop nodes near others to auto-link.', color:'#fff8f0', shape:'soft' });
    saveModel();
  }
  updateGrid(); renderNodes(); applyTransform();
  if(!localStorage.getItem(tutorialKey)) showTutorial(0);

  /* Optional: expose debug helper to show anchor points */
  window.__aries = window.__aries || {};
  window.__aries.showAnchors = function(show){
    document.querySelectorAll('.anchor-debug').forEach(el=>el.remove());
    if(!show) return;
    model.nodes.forEach(n=>{
      const anchors = computeAnchors(n);
      anchors.forEach((a,i)=>{
        const d = document.createElement('div'); d.className='anchor-debug'; d.style.left = (a.x)+'px'; d.style.top = (a.y)+'px'; d.style.display='block'; canvas.appendChild(d);
      });
    });
  };

  window.__ariesWorkspace = { model, saveModel, addNodeAt: (x,y)=>addNodeAt(x,y) };

})();
</script>
</body>
</html>
