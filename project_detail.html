<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Visual Blocks Studio</title>
<style>
  :root {
    --bg: #0b0f14;
    --panel: #11161d;
    --panel2: #0f141a;
    --border: #2a3440;
    --accent: #36a3ff;
    --accent2: #10b981;
    --text: #d6e3f0;
    --muted: #8aa0b8;
  }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; }
  .app { display: grid; grid-template-columns: 300px 1fr; grid-template-rows: auto 1fr; height: 100%; }
  .toolbar { grid-column: 1 / -1; display: flex; gap: 8px; align-items: center; padding: 10px; border-bottom: 1px solid var(--border); background: linear-gradient(180deg,var(--panel),var(--panel2)); position: sticky; top:0; z-index:10; }
  .toolbar button, .toolbar input, .toolbar select { background: #16202b; color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 6px 10px; font-size: 13px; }
  .toolbar button:hover { border-color: var(--accent); }
  .sidebar { grid-row: 2; border-right: 1px solid var(--border); background: var(--panel); display:flex; flex-direction:column; }
  .section { padding: 12px; border-bottom: 1px solid var(--border); }
  .section h3 { margin: 0 0 8px; font-size: 13px; color: var(--muted); text-transform: uppercase; letter-spacing: .08em; }
  .canvas-wrap { position: relative; overflow: hidden; }
  .hud { position: absolute; bottom: 10px; left: 10px; background: #10151b; border: 1px solid var(--border); border-radius: 6px; padding: 6px 10px; font-size: 12px; color: var(--muted); z-index: 5; }
  .grid { pointer-events:none; }
  .block-rect { fill: #101721; stroke: #334458; stroke-width: 1.5; }
  .block-rect.selected { stroke: var(--accent); }
  .handle { fill: var(--accent); cursor: nwse-resize; }
  .connector { stroke: #4d627a; stroke-width: 2; marker-end: url(#arrow); }
  .connector.selected { stroke: var(--accent2); }
  .label-fo div { font-size: 12px; color: var(--text); }
  .tag { display:inline-block; background:#16202b; border:1px solid var(--border); border-radius:12px; padding:2px 8px; margin:2px 4px 0 0; font-size:11px; color:#b8c7d6; }
  .btn-danger { border-color: #ef4444; color: #fca5a5; }
  .btn-primary { border-color: var(--accent); color: #cdeaff; }
  .btn-success { border-color: var(--accent2); color: #bdf2dc; }
  .ghost-line { stroke: #2b3a4a; stroke-dasharray: 4 4; }
  .snap-dot { fill: #2b3a4a; }
  .tooltip { position:absolute; background:#0f141a; border:1px solid var(--border); color:var(--text); font-size:12px; padding:6px 8px; border-radius:6px; pointer-events:none; transform:translate(-50%,-120%); white-space:nowrap; }
</style>
</head>
<body>
<div class="app">
  <div class="toolbar">
    <button id="addText">+ Text</button>
    <button id="addNote">+ Note</button>
    <button id="addFrame">+ Frame</button>
    <button id="addChart">+ Chart</button>
    <label>
      <input type="file" id="addImage" accept="image/*" style="display:none" />
      <button id="addImageBtn">+ Image</button>
    </label>
    <button id="addConnector">↗ Connector</button>
    <button id="snapshot" class="btn-success">Snapshot</button>
    <button id="saveLocal" class="btn-primary">Save</button>
    <button id="loadLocal">Load</button>
    <button id="exportPNG" class="btn-primary">Export PNG</button>
    <button id="clear" class="btn-danger">Clear</button>
    <span style="margin-left:auto; color:var(--muted)">Pan: Right-Drag • Zoom: Ctrl + Wheel • Snap: Shift</span>
  </div>

  <div class="sidebar">
    <div class="section">
      <h3>Inspector</h3>
      <div id="inspector"></div>
    </div>
    <div class="section">
      <h3>Tags</h3>
      <div id="tagsPanel"></div>
      <div style="margin-top:8px;">
        <input id="newTag" placeholder="Add tag…" />
        <button id="addTagBtn">Add</button>
      </div>
    </div>
    <div class="section">
      <h3>Snapshots</h3>
      <div id="snapshots"></div>
    </div>
    <div class="section">
      <h3>Views</h3>
      <div style="display:flex; gap:6px;">
        <input id="viewName" placeholder="View name…" />
        <button id="saveView">Save view</button>
      </div>
      <div id="viewsList" style="margin-top:8px;"></div>
    </div>
  </div>

  <div class="canvas-wrap" id="canvasWrap">
    <svg id="svg" width="100%" height="100%">
      <defs>
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
          <path d="M0,0 L9,3 L0,6 Z" fill="#4d627a"></path>
        </marker>
      </defs>
      <g id="viewport">
        <g id="grid" class="grid"></g>
        <g id="connectors"></g>
        <g id="blocks"></g>
        <g id="handles"></g>
        <g id="overlay"></g>
      </g>
    </svg>
    <div class="hud" id="hud">0 blocks • Zoom 1.00 • View default</div>
    <div id="tooltip" class="tooltip" style="display:none;"></div>
  </div>
</div>

<script>
/* ========= Utility ========= */
const rnd = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
const uid = () => crypto.randomUUID();

function createGrid() {
  const g = document.getElementById('grid');
  g.innerHTML = '';
  const step = 40;
  for (let i=-2000; i<=2000; i+=step) {
    const h = line(-2000, i, 2000, i);
    const v = line(i, -2000, i, 2000);
    h.setAttribute('class','ghost-line');
    v.setAttribute('class','ghost-line');
    g.appendChild(h); g.appendChild(v);
  }
}

function line(x1,y1,x2,y2) {
  const l = document.createElementNS('http://www.w3.org/2000/svg','line');
  l.setAttribute('x1',x1); l.setAttribute('y1',y1);
  l.setAttribute('x2',x2); l.setAttribute('y2',y2);
  l.setAttribute('stroke','#1f2a36'); l.setAttribute('stroke-width','1');
  return l;
}

function rect(x,y,w,h, cls='') {
  const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
  r.setAttribute('x',x); r.setAttribute('y',y);
  r.setAttribute('width',w); r.setAttribute('height',h);
  if (cls) r.setAttribute('class', cls);
  return r;
}

function group(cls='') {
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  if (cls) g.setAttribute('class', cls);
  return g;
}

function foreignObject(x,y,w,h, html='') {
  const fo = document.createElementNS('http://www.w3.org/2000/svg','foreignObject');
  fo.setAttribute('x',x); fo.setAttribute('y',y);
  fo.setAttribute('width',w); fo.setAttribute('height',h);
  const div = document.createElement('div');
  div.innerHTML = html;
  div.style.color = 'var(--text)';
  fo.appendChild(div);
  return fo;
}

function path(d, cls='') {
  const p = document.createElementNS('http://www.w3.org/2000/svg','path');
  p.setAttribute('d', d);
  if (cls) p.setAttribute('class', cls);
  return p;
}

function download(name, dataUrl) {
  const a = document.createElement('a');
  a.href = dataUrl; a.download = name;
  document.body.appendChild(a); a.click(); a.remove();
}

function toDataURL(svgEl) {
  const s = new XMLSerializer().serializeToString(svgEl);
  const blob = new Blob([s], { type: 'image/svg+xml;charset=utf-8' });
  return URL.createObjectURL(blob);
}

function svgToPNG(svgEl, scale=2) {
  return new Promise((resolve) => {
    const xml = new XMLSerializer().serializeToString(svgEl);
    const svg64 = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(xml);
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const b = svgEl.getBoundingClientRect();
      canvas.width = b.width * scale; canvas.height = b.height * scale;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = getComputedStyle(document.body).backgroundColor;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      resolve(canvas.toDataURL('image/png'));
    };
    img.src = svg64;
  });
}

/* ========= State ========= */
const state = {
  blocks: [],           // {id,type,x,y,w,h,content,props,tags:[]}
  connectors: [],       // {id,from,to,label}
  selected: null,       // id of block or connector
  mode: 'select',       // 'select' | 'addConnector'
  pan: {x: 0, y: 0},
  zoom: 1,
  views: {},            // name -> {blocks, connectors}
  snapshots: [],        // [{id, ts, note, viewName}]
};

const svg = document.getElementById('svg');
const viewport = document.getElementById('viewport');
const blocksG = document.getElementById('blocks');
const handlesG = document.getElementById('handles');
const connectorsG = document.getElementById('connectors');
const hud = document.getElementById('hud');
const tooltip = document.getElementById('tooltip');

function updateHUD() {
  hud.textContent = `${state.blocks.length} blocks • Zoom ${state.zoom.toFixed(2)} • View ${currentViewName()}`;
}

/* ========= Rendering ========= */
function render() {
  connectorsG.innerHTML = '';
  for (const c of state.connectors) {
    const from = state.blocks.find(b => b.id === c.from);
    const to = state.blocks.find(b => b.id === c.to);
    if (!from || !to) continue;
    const x1 = from.x + from.w/2, y1 = from.y + from.h/2;
    const x2 = to.x + to.w/2, y2 = to.y + to.h/2;
    const d = `M ${x1} ${y1} L ${x2} ${y2}`;
    const p = path(d, 'connector' + (state.selected === c.id ? ' selected' : ''));
    p.setAttribute('data-id', c.id);
    connectorsG.appendChild(p);
  }

  blocksG.innerHTML = '';
  handlesG.innerHTML = '';
  for (const b of state.blocks) {
    const g = group();
    const r = rect(b.x, b.y, b.w, b.h, 'block-rect' + (state.selected === b.id ? ' selected' : ''));
    r.setAttribute('rx', 8);
    r.setAttribute('data-id', b.id);
    g.appendChild(r);

    const padding = 10;
    const fo = foreignObject(b.x+padding, b.y+padding, b.w-2*padding, b.h-2*padding);
    const div = fo.firstChild;
    div.style.fontSize = '13px';
    div.style.lineHeight = '1.4';

    if (b.type === 'text') {
      div.contentEditable = 'true';
      div.innerHTML = b.content || '<h3>New Idea</h3><p>Describe...</p>';
      div.addEventListener('input', () => { b.content = div.innerHTML; saveAutosync(); });
    } else if (b.type === 'note') {
      div.contentEditable = 'true';
      div.innerHTML = b.content || '<p><strong>Note:</strong> jot something down…</p>';
      div.addEventListener('input', () => { b.content = div.innerHTML; saveAutosync(); });
      r.style.fill = '#16212a';
    } else if (b.type === 'frame') {
      div.innerHTML = b.content || '<strong>Frame</strong><br/><span style="color:var(--muted)">Group related blocks conceptually.</span>';
      r.style.fill = '#0c1218';
      r.style.strokeDasharray = '6 4';
    } else if (b.type === 'chart') {
      div.innerHTML = `<div style="color:var(--muted)">Chart placeholder</div>
        <div>Series: <strong>${(b.props && b.props.seriesId) || 'DGS10'}</strong></div>
        <div style="margin-top:6px;font-size:12px;color:#97b0c8">Bind real data in a full app; here it’s a visual stub.</div>`;
      r.style.fill = '#121a22';
    } else if (b.type === 'image') {
      div.innerHTML = `<img src="${b.props.url}" style="max-width:100%;max-height:${b.h-20}px;border-radius:6px;" />` +
                      (b.content ? `<div style="margin-top:6px;color:var(--muted)">${b.content}</div>` : '');
      r.style.fill = '#0f151c';
    }

    // Tags line
    if (b.tags && b.tags.length) {
      const tagsHTML = b.tags.map(t => `<span class="tag">${t}</span>`).join('');
      const tagsFO = foreignObject(b.x+padding, b.y+b.h-24, b.w-2*padding, 20, `<div>${tagsHTML}</div>`);
      g.appendChild(tagsFO);
    }

    // Resizer handle
    const h = rect(b.x + b.w - 8, b.y + b.h - 8, 8, 8, 'handle');
    h.setAttribute('data-id', b.id);
    handlesG.appendChild(h);

    blocksG.appendChild(g);
  }
  updateInspector();
  updateTagsPanel();
  updateSnapshots();
  updateViewsList();
  updateHUD();
}
createGrid();

/* ========= Selection & interactions ========= */
let dragging = null; // { id, dx, dy }
let resizing = null; // { id, ox, oy, ow, oh }
let panning = null;  // { sx, sy, ox, oy }

function screenToWorld(x,y) {
  const vb = viewport.getAttribute('transform');
  let tx=state.pan.x, ty=state.pan.y, s=state.zoom;
  return { x: (x/s)-tx, y: (y/s)-ty };
}

function worldToScreen(x,y) {
  return { x: (x + state.pan.x) * state.zoom, y: (y + state.pan.y) * state.zoom };
}

function applyViewport() {
  viewport.setAttribute('transform', `translate(${state.pan.x*state.zoom},${state.pan.y*state.zoom}) scale(${state.zoom})`);
}
applyViewport();

function findBlockByEl(target) {
  const id = target.getAttribute('data-id');
  return state.blocks.find(b => b.id === id);
}

svg.addEventListener('mousedown', (e) => {
  const pt = screenToWorld(e.clientX, e.clientY);
  const target = e.target;

  if (e.button === 2) { // right-click drag for pan
    panning = { sx: e.clientX, sy: e.clientY, ox: state.pan.x, oy: state.pan.y };
    return;
  }

  if (target.classList.contains('handle')) {
    const b = findBlockByEl(target);
    state.selected = b.id;
    const bb = { ox: b.x, oy: b.y, ow: b.w, oh: b.h };
    resizing = { id: b.id, ...bb };
    render();
    return;
  }

  if (target.classList.contains('block-rect')) {
    const b = findBlockByEl(target);
    state.selected = b.id;
    dragging = { id: b.id, dx: pt.x - b.x, dy: pt.y - b.y };
    render();
    return;
  }

  // connector selection
  if (target.tagName === 'path' && target.classList.contains('connector')) {
    const id = target.getAttribute('data-id');
    state.selected = id;
    render();
    return;
  }

  // blank click clears selection
  state.selected = null;
  render();
});

svg.addEventListener('mousemove', (e) => {
  const pt = screenToWorld(e.clientX, e.clientY);
  if (dragging) {
    const b = state.blocks.find(x => x.id === dragging.id);
    let nx = pt.x - dragging.dx, ny = pt.y - dragging.dy;
    if (e.shiftKey) { // snap-to-grid
      const step = 20;
      nx = Math.round(nx/step)*step; ny = Math.round(ny/step)*step;
    }
    b.x = nx; b.y = ny;
    render();
    return;
  }
  if (resizing) {
    const b = state.blocks.find(x => x.id === resizing.id);
    const w = clamp(pt.x - b.x, 120, 1200);
    const h = clamp(pt.y - b.y, 80, 800);
    b.w = e.shiftKey ? Math.round(w/20)*20 : w;
    b.h = e.shiftKey ? Math.round(h/20)*20 : h;
    render();
    return;
  }
  if (panning) {
    const dx = (e.clientX - panning.sx) / state.zoom;
    const dy = (e.clientY - panning.sy) / state.zoom;
    state.pan.x = panning.ox + dx;
    state.pan.y = panning.oy + dy;
    applyViewport();
    return;
  }
});

window.addEventListener('mouseup', () => {
  if (dragging || resizing) saveAutosync();
  dragging = null; resizing = null; panning = null;
});

svg.addEventListener('contextmenu', (e) => e.preventDefault());

svg.addEventListener('wheel', (e) => {
  if (e.ctrlKey) {
    e.preventDefault();
    const delta = e.deltaY < 0 ? 0.1 : -0.1;
    const newZ = clamp(state.zoom + delta, 0.3, 3);
    // zoom at cursor
    const before = screenToWorld(e.clientX, e.clientY);
    state.zoom = newZ;
    applyViewport();
    const after = screenToWorld(e.clientX, e.clientY);
    state.pan.x += (after.x - before.x);
    state.pan.y += (after.y - before.y);
    applyViewport();
    updateHUD();
  }
});

/* ========= CRUD ========= */
function addBlock(type, props={}) {
  const id = uid();
  const b = {
    id, type,
    x: rnd(-200, 200), y: rnd(-100, 200),
    w: type==='note' ? 240 : 320,
    h: type==='image' ? 240 : (type==='note' ? 140 : 200),
    content: '',
    props,
    tags: []
  };
  if (type === 'text') b.content = '<h3>New Idea</h3><p>Describe...</p>';
  state.blocks.push(b);
  state.selected = id;
  render(); saveAutosync();
}

function removeSelected() {
  if (!state.selected) return;
  const isConnector = state.connectors.some(c => c.id === state.selected);
  if (isConnector) {
    state.connectors = state.connectors.filter(c => c.id !== state.selected);
  } else {
    state.blocks = state.blocks.filter(b => b.id !== state.selected);
    state.connectors = state.connectors.filter(c => c.from !== state.selected && c.to !== state.selected);
  }
  state.selected = null;
  render(); saveAutosync();
}

function addConnectorMode() {
  state.mode = 'addConnector';
  showTip('Click source block, then target block to connect.');
}

let connectorDraft = null;
svg.addEventListener('click', (e) => {
  if (state.mode !== 'addConnector') return;
  const t = e.target;
  if (!t.classList.contains('block-rect')) return;
  const b = findBlockByEl(t);
  if (!connectorDraft) {
    connectorDraft = { from: b.id };
    showTip('Now click target block.');
  } else {
    const id = uid();
    state.connectors.push({ id, from: connectorDraft.from, to: b.id, label: '' });
    connectorDraft = null;
    state.mode = 'select';
    hideTip();
    render(); saveAutosync();
  }
});

/* ========= Inspector ========= */
const inspector = document.getElementById('inspector');

function updateInspector() {
  inspector.innerHTML = '';
  if (!state.selected) {
    inspector.innerHTML = '<div style="color:var(--muted)">No selection</div>';
    return;
  }
  const conn = state.connectors.find(c => c.id === state.selected);
  if (conn) {
    inspector.innerHTML = `
      <div><strong>Connector</strong></div>
      <div style="margin-top:8px;">
        <label>Label</label>
        <input id="connLabel" value="${conn.label}" />
      </div>
      <div style="margin-top:8px;">
        <button id="deleteSel" class="btn-danger">Delete</button>
      </div>
    `;
    document.getElementById('connLabel').addEventListener('input', (e)=>{ conn.label = e.target.value; render(); saveAutosync(); });
    document.getElementById('deleteSel').addEventListener('click', removeSelected);
    return;
  }

  const b = state.blocks.find(x => x.id === state.selected);
  if (!b) return;
  inspector.innerHTML = `
    <div><strong>Block</strong> · <span style="color:var(--muted)">${b.type}</span></div>
    <div style="margin-top:8px; display:grid; grid-template-columns: 1fr 1fr; gap:6px;">
      <label>X <input id="ix" type="number" value="${b.x}"></label>
      <label>Y <input id="iy" type="number" value="${b.y}"></label>
      <label>W <input id="iw" type="number" value="${b.w}"></label>
      <label>H <input id="ih" type="number" value="${b.h}"></label>
    </div>
    <div style="margin-top:8px;">
      <label>Content</label>
      <textarea id="icontent" rows="4" style="width:100%">${b.content || ''}</textarea>
    </div>
    ${b.type==='chart' ? `
      <div style="margin-top:8px;">
        <label>Series ID</label>
        <input id="iseries" value="${(b.props && b.props.seriesId) || ''}">
      </div>` : ''}
    ${b.type==='image' ? `
      <div style="margin-top:8px;">
        <label>Caption</label>
        <input id="icap" value="${b.content || ''}">
      </div>` : ''}
    <div style="margin-top:8px;">
      <label>Tags</label>
      <input id="itags" placeholder="comma,separated" value="${(b.tags||[]).join(',')}">
    </div>
    <div style="margin-top:8px; display:flex; gap:6px;">
      <button id="deleteSel" class="btn-danger">Delete</button>
    </div>
  `;
  document.getElementById('ix').addEventListener('input',(e)=>{ b.x = parseFloat(e.target.value||0); render(); saveAutosync(); });
  document.getElementById('iy').addEventListener('input',(e)=>{ b.y = parseFloat(e.target.value||0); render(); saveAutosync(); });
  document.getElementById('iw').addEventListener('input',(e)=>{ b.w = clamp(parseFloat(e.target.value||0),120,1200); render(); saveAutosync(); });
  document.getElementById('ih').addEventListener('input',(e)=>{ b.h = clamp(parseFloat(e.target.value||0),80,800); render(); saveAutosync(); });
  const ic = document.getElementById('icontent');
  ic.addEventListener('input', (e)=>{ b.content = e.target.value; render(); saveAutosync(); });
  const del = document.getElementById('deleteSel'); del.addEventListener('click', removeSelected);
  const it = document.getElementById('itags'); it.addEventListener('input', (e)=>{ b.tags = e.target.value.split(',').map(s=>s.trim()).filter(Boolean); render(); saveAutosync(); });
  const is = document.getElementById('iseries'); if (is) is.addEventListener('input',(e)=>{ b.props = {...(b.props||{}), seriesId: e.target.value }; render(); saveAutosync(); });
  const icap = document.getElementById('icap'); if (icap) icap.addEventListener('input',(e)=>{ b.content = e.target.value; render(); saveAutosync(); });
}

/* ========= Tags ========= */
const tagsPanel = document.getElementById('tagsPanel');
function allTags() {
  const set = new Set();
  state.blocks.forEach(b => (b.tags||[]).forEach(t => set.add(t)));
  return Array.from(set);
}
function updateTagsPanel() {
  const tags = allTags();
  tagsPanel.innerHTML = tags.length ? tags.map(t => `<span class="tag" data-tag="${t}">${t}</span>`).join('') : '<div style="color:var(--muted)">No tags yet</div>';
  tagsPanel.querySelectorAll('.tag').forEach(el => {
    el.addEventListener('click', () => filterByTag(el.getAttribute('data-tag')));
  });
}
function filterByTag(tag) {
  state.selected = null;
  blocksG.querySelectorAll('.block-rect').forEach(r => {
    const b = state.blocks.find(x => x.id === r.getAttribute('data-id'));
    const has = (b.tags||[]).includes(tag);
    r.style.opacity = has ? 1 : 0.2;
  });
}
document.getElementById('addTagBtn').addEventListener('click', () => {
  const input = document.getElementById('newTag');
  const t = input.value.trim();
  if (!t || !state.selected) return;
  const b = state.blocks.find(x => x.id === state.selected);
  b.tags = Array.from(new Set([...(b.tags||[]), t]));
  input.value = '';
  render(); saveAutosync();
});

/* ========= Snapshots & Views ========= */
function currentViewName() {
  return Object.keys(state.views).find(v => JSON.stringify(state.views[v].blocks.map(b=>b.id)) === JSON.stringify(state.blocks.map(b=>b.id))) || 'default';
}
function snapshot(note='') {
  const id = uid();
  state.snapshots.unshift({ id, ts: Date.now(), note, viewName: currentViewName() });
  render(); saveAutosync();
}
function updateSnapshots() {
  const el = document.getElementById('snapshots');
  if (!state.snapshots.length) { el.innerHTML = '<div style="color:var(--muted)">No snapshots yet</div>'; return; }
  el.innerHTML = state.snapshots.map(s => {
    const d = new Date(s.ts); const time = d.toLocaleString();
    return `<div style="margin-bottom:8px;"><strong>${time}</strong><br/><span style="color:var(--muted)">${s.note||'Snapshot'}</span></div>`;
  }).join('');
}
function saveView(name) {
  state.views[name] = {
    blocks: JSON.parse(JSON.stringify(state.blocks)),
    connectors: JSON.parse(JSON.stringify(state.connectors)),
    pan: {...state.pan},
    zoom: state.zoom,
  };
  render(); saveAutosync();
}
function loadView(name) {
  const v = state.views[name];
  if (!v) return;
  state.blocks = JSON.parse(JSON.stringify(v.blocks));
  state.connectors = JSON.parse(JSON.stringify(v.connectors));
  state.pan = {...v.pan}; state.zoom = v.zoom;
  applyViewport(); render(); saveAutosync();
}
function updateViewsList() {
  const el = document.getElementById('viewsList');
  const names = Object.keys(state.views);
  if (!names.length) { el.innerHTML = '<div style="color:var(--muted)">No views saved</div>'; return; }
  el.innerHTML = names.map(n => `<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">
    <span>${n}</span><button data-view="${n}">Load</button>
  </div>`).join('');
  el.querySelectorAll('button').forEach(btn => btn.addEventListener('click', () => loadView(btn.getAttribute('data-view'))));
}

/* ========= Tooltip ========= */
function showTip(txt, x=null, y=null) {
  tooltip.textContent = txt;
  tooltip.style.display = 'block';
  if (x!=null && y!=null) { tooltip.style.left = x+'px'; tooltip.style.top = y+'px'; }
}
function hideTip() { tooltip.style.display = 'none'; }

/* ========= Persistence ========= */
function saveAutosync() {
  localStorage.setItem('visual_blocks_state', JSON.stringify(state));
  updateHUD();
}
function loadAutosync() {
  const raw = localStorage.getItem('visual_blocks_state');
  if (!raw) return;
  try {
    const s = JSON.parse(raw);
    Object.assign(state, s);
    applyViewport();
    render();
  } catch(e) { console.warn('Failed to load state', e); }
}

/* ========= Controls ========= */
document.getElementById('addText').addEventListener('click', () => addBlock('text'));
document.getElementById('addNote').addEventListener('click', () => addBlock('note'));
document.getElementById('addFrame').addEventListener('click', () => addBlock('frame'));
document.getElementById('addChart').addEventListener('click', () => addBlock('chart'));
document.getElementById('addImageBtn').addEventListener('click', () => document.getElementById('addImage').click());
document.getElementById('addImage').addEventListener('change', (e) => {
  const file = e.target.files[0]; if (!file) return;
  const url = URL.createObjectURL(file);
  addBlock('image', { url });
  e.target.value = '';
});
document.getElementById('addConnector').addEventListener('click', addConnectorMode);

document.getElementById('snapshot').addEventListener('click', () => {
  const note = prompt('Snapshot note (optional):', '');
  snapshot(note||'');
});

document.getElementById('saveLocal').addEventListener('click', () => {
  saveAutosync();
  showTip('Saved to local storage');
  setTimeout(hideTip, 1000);
});
document.getElementById('loadLocal').addEventListener('click', () => {
  loadAutosync();
  showTip('Loaded from local storage');
  setTimeout(hideTip, 1000);
});

document.getElementById('exportPNG').addEventListener('click', async () => {
  const dataUrl = await svgToPNG(svg, 2);
  download('visual_blocks.png', dataUrl);
});

document.getElementById('clear').addEventListener('click', () => {
  if (!confirm('Clear all blocks and connectors?')) return;
  state.blocks = []; state.connectors = []; state.selected = null; state.snapshots = []; state.views = {};
  render(); saveAutosync();
});

document.getElementById('saveView').addEventListener('click', () => {
  const name = document.getElementById('viewName').value.trim();
  if (!name) return alert('Provide a view name');
  saveView(name);
});

/* ========= Keyboard shortcuts ========= */
window.addEventListener('keydown', (e) => {
  if (e.key === 'Delete') removeSelected();
  if (e.metaKey || e.ctrlKey) {
    if (e.key.toLowerCase() === 's') { e.preventDefault(); saveAutosync(); showTip('Saved'); setTimeout(hideTip, 800); }
    if (e.key.toLowerCase() === 'e') { e.preventDefault(); document.getElementById('exportPNG').click(); }
  }
});

/* ========= Init ========= */
render();
loadAutosync();
</script>
</body>
</html>
