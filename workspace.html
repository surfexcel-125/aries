<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idea Visualizer — Premium Dark (Firebase Autosave per Project)</title>
<style>
  :root{--bg:#071019; --card:#0f1720; --muted:#90a0b8; --accent:#8b5cf6; --glass: rgba(255,255,255,0.03);} *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef8;background:linear-gradient(180deg,var(--bg),#041018)}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px 20px;background:#0f1720;border-bottom:1px solid rgba(255,255,255,0.04)}
  h1{margin:0;font-size:16px;color:#e6eef8}
  main{display:flex;gap:20px;padding:20px}
  aside{width:320px;background:#0f1720;border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:16px}
  label{font-size:13px;color:var(--muted)}
  textarea,input{width:100%;padding:10px;margin-top:6px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04);color:#e6eef8;resize:vertical}
  button{cursor:pointer;border-radius:8px;padding:8px 12px;border:none}
  .btn{background:linear-gradient(90deg,var(--accent),#06b6d4);color:white}
  .muted{color:var(--muted);font-size:13px}

  /* Canvas area */
  #canvasWrap{flex:1;height:600px;border:1px solid rgba(255,255,255,0.03);border-radius:12px;position:relative;background:linear-gradient(180deg,#071019,#041018);overflow:hidden;touch-action:none}
  /* boardArea is transformed; set large virtual size */
  #boardArea{width:4000px;height:2500px;position:absolute;left:0;top:0;transform-origin:0 0}
  .node{position:absolute;min-width:160px;padding:12px;border-radius:10px;color:#e6eef8;background:linear-gradient(180deg,#0f1820,#071117);border:1px solid rgba(255,255,255,0.04);box-shadow:0 18px 40px rgba(2,6,23,0.6);user-select:none}
  .node .title{font-weight:700;margin-bottom:4px}
  .node .meta{font-size:12px;color:var(--muted);white-space:pre-wrap}
  .connector{width:14px;height:14px;border-radius:50%;background:var(--accent);position:absolute;right:8px;top:50%;transform:translateY(-50%);cursor:pointer;box-shadow:0 6px 14px rgba(139,92,246,0.25);border:2px solid rgba(255,255,255,0.06);pointer-events:auto;z-index:20}
  /* SVG matches board coordinates */
  #svgLayer{position:absolute;left:0;top:0;width:4000px;height:2500px;pointer-events:none}

  /* hide native scrollbars if any */
  #canvasWrap::-webkit-scrollbar{display:none}
  #canvasWrap{ -ms-overflow-style: none; scrollbar-width: none; }

  .node.connecting{box-shadow:0 24px 60px rgba(139,92,246,0.35);border-color:rgba(139,92,246,0.6)}
  .node.selected{outline:2px solid rgba(139,92,246,0.45);box-shadow:0 24px 60px rgba(139,92,246,0.12)}

  /* Modal */
  .modal-backdrop{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:1000}
  .modal{background:#08121a;padding:18px;border-radius:12px;min-width:320px;border:1px solid rgba(255,255,255,0.04)}
  .modal input,.modal textarea{width:100%;margin-top:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:8px;color:#e6eef8}
  .row{display:flex;gap:8px}
  .small{padding:6px 8px;font-size:13px}
</style>
</head>
<body>
<header>
  <h1>Idea Visualizer — Premium Dark</h1>
  <div style="display:flex;gap:8px;align-items:center">
    <button id="btn-undo" class="btn small" title="Undo (Ctrl+Z)">Undo</button>
    <button id="btn-redo" class="btn small" title="Redo (Ctrl+Y)">Redo</button>
    <button id="btn-fit" class="btn">Fit</button>
    <button id="btn-export" class="btn">Export SVG</button>
  </div>
</header>
<main>
<aside>
  <!-- Project controls -->
  <label>Project ID</label>
  <div style="display:flex;gap:8px;margin-top:6px">
    <input id="projectIdInput" placeholder="e.g. eu-session-plan" />
    <button id="btn-load-project" class="btn" style="flex-shrink:0">Load</button>
  </div>
  <div class="muted" style="margin-top:6px;margin-bottom:10px">
    Boards are auto-saved per project to Firebase.
  </div>
  <hr style="border:none;border-top:1px solid rgba(255,255,255,0.06);margin:10px 0 14px" />

  <!-- Existing controls -->
  <label>Card</label>
  <textarea id="ideaText" rows="3" placeholder="Card titles — one per line"></textarea>
  <label style="margin-top:10px">Body (one per line)</label>
  <textarea id="cardBody" rows="5" placeholder="Optional: body text for each node — one per line"></textarea>
  <div style="display:flex;gap:8px;margin-top:10px">
    <button id="btn-create" class="btn">Create Nodes</button>
    <button id="btn-workflow" class="btn">Create Workflow</button>
  </div>
  <div style="display:flex;gap:8px;margin-top:10px">
    <button id="btn-delete" class="btn" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)">Delete Selected</button>
    <button id="btn-clear" class="btn" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)">Clear</button>
  </div>
  <div style="margin-top:12px" class="muted">Tips: Drag empty background to pan. Use mouse wheel to zoom. Click connector dot then click target node to link. Double-click a node to edit. Use Undo/Redo or Delete key to remove selected node.</div>
</aside>
<div id="canvasWrap">
  <div id="boardArea">
    <svg id="svgLayer" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
</div>
</main>

<!-- Modal for editing node (in-canvas) -->
<div id="modal" class="modal-backdrop" role="dialog" aria-hidden="true">
  <div class="modal" role="document">
    <div style="font-weight:700">Edit Node</div>
    <label style="margin-top:8px">Title</label>
    <input id="modalTitle" type="text" />
    <label style="margin-top:8px">Body</label>
    <textarea id="modalBody" rows="4"></textarea>
    <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:12px">
      <button id="modalCancel" class="btn small" style="background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)">Cancel</button>
      <button id="modalSave" class="btn small">Save</button>
    </div>
  </div>
</div>

<!-- IMPORTANT: your firebase.config.js must initialize Firebase and set window.ideaVisualizerDb = firebase.firestore() -->
<script src="firebase.config.js"></script>

<script>
(() => {
  // ---------- state & history ----------
  const state = {
    nodes: [], links: [], selected: null, nodeId: 1,
    view: { x: 0, y: 0, scale: 1 },
    connecting: null
  };

  // Firebase / autosave state
  const SAVE_DEBOUNCE_MS = 1200;
  let saveTimeout = null;
  let currentProjectId = null;

  // Firestore instance:
  // firebase.config.js should do:
  //   const app = firebase.initializeApp(firebaseConfig);
  //   window.ideaVisualizerDb = firebase.firestore();
  const db = (typeof window !== 'undefined' && (window.ideaVisualizerDb || (window.firebase && window.firebase.firestore ? window.firebase.firestore() : null))) || null;

  const history = { past: [], future: [], max: 60 };

  function snapshot(){
    // create deep copy snapshot of minimal state needed
    const snap = {
      nodes: state.nodes.map(n => ({ id: n.id, x: n.x, y: n.y, title: n.title, notes: n.notes })),
      links: state.links.map(l => ({ from: l.from, to: l.to })),
      nodeId: state.nodeId,
      view: { x: state.view.x, y: state.view.y, scale: state.view.scale },
      selected: state.selected
    };
    return snap;
  }

  function applySnapshot(snap){
    // clear board + render nodes from snapshot
    state.nodes.forEach(n => { if(n.el && n.el.parentNode) n.el.parentNode.removeChild(n.el); });
    state.nodes = [];
    state.links = [];
    state.nodeId = snap.nodeId || 1;
    state.view = snap.view ? { ...snap.view } : { x:0,y:0,scale:1 };

    // create nodes without altering history
    (snap.nodes || []).forEach(n => {
      createNode(n.x, n.y, n.title, n.notes, { id: n.id, addToState: true, skipHistory: true });
    });
    state.links = (snap.links || []).map(l => ({ from: l.from, to: l.to }));
    state.selected = snap.selected || null;
    applyView();
    drawLinks();
    updateSelectionVisual();
  }

  function updateUndoRedoButtons(){
    document.getElementById('btn-undo').disabled = history.past.length === 0;
    document.getElementById('btn-redo').disabled = history.future.length === 0;
  }

  function scheduleSave(){
    if(!currentProjectId || !db) return;
    if(saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(saveToFirebase, SAVE_DEBOUNCE_MS);
  }

  function pushHistory(){ // push current state to past, clear future
    const s = snapshot();
    history.past.push(s);
    if(history.past.length > history.max) history.past.shift();
    history.future = [];
    updateUndoRedoButtons();
    scheduleSave();
  }

  function undo(){
    if(history.past.length === 0) return;
    const current = snapshot();
    history.future.push(current);
    const prev = history.past.pop();
    applySnapshot(prev);
    updateUndoRedoButtons();
    scheduleSave();
  }

  function redo(){
    if(history.future.length === 0) return;
    const current = snapshot();
    history.past.push(current);
    const next = history.future.pop();
    applySnapshot(next);
    updateUndoRedoButtons();
    scheduleSave();
  }

  // ---------- Firebase save/load ----------
  async function saveToFirebase(){
    if(!currentProjectId || !db) return;
    const payload = snapshot();
    payload.updatedAt = new Date().toISOString();
    try {
      await db.collection('ideaVisualizerProjects').doc(currentProjectId).set(payload, { merge: true });
      console.log('Saved project to Firebase:', currentProjectId);
    } catch(err){
      console.error('Error saving project to Firebase:', err);
    }
  }

  async function loadFromFirebase(projectId){
    if(!db){
      console.warn('Firebase DB not available; using local-only mode.');
      initializeDefaultBoard();
      return;
    }
    try{
      const docRef = db.collection('ideaVisualizerProjects').doc(projectId);
      const snap = await docRef.get();
      if(snap.exists){
        const data = snap.data() || {};
        const restored = {
          nodes: Array.isArray(data.nodes) ? data.nodes : [],
          links: Array.isArray(data.links) ? data.links : [],
          nodeId: data.nodeId || 1,
          view: data.view || { x:0, y:0, scale:1 },
          selected: null
        };
        applySnapshot(restored);
        history.past = [];
        history.future = [];
        pushHistory(); // establish baseline + schedule save
        console.log('Loaded project from Firebase:', projectId);
      } else {
        console.log('No existing project in Firebase, starting fresh:', projectId);
        // Start empty board (no default sample nodes for new project)
        state.nodes.forEach(n => { if(n.el && n.el.parentNode) n.el.parentNode.removeChild(n.el); });
        state.nodes = [];
        state.links = [];
        while(svg.firstChild) svg.removeChild(svg.firstChild);
        state.nodeId = 1;
        state.view = { x:0, y:0, scale:1 };
        applyView();
        drawLinks();
        history.past = [];
        history.future = [];
        pushHistory();
      }
    } catch(err){
      console.error('Error loading project from Firebase:', err);
      initializeDefaultBoard();
    }
  }

  function setCurrentProject(projectId){
    const trimmed = (projectId || '').trim();
    if(!trimmed) return;
    currentProjectId = trimmed;
    try{
      localStorage.setItem('ideaVisualizerCurrentProjectId', currentProjectId);
    }catch(e){}
    loadFromFirebase(currentProjectId);
  }

  // ---------- DOM references ----------
  const wrap = document.getElementById('canvasWrap');
  const board = document.getElementById('boardArea');
  const svg = document.getElementById('svgLayer');
  const modal = document.getElementById('modal');
  const modalTitle = document.getElementById('modalTitle');
  const modalBody = document.getElementById('modalBody');
  const projectInput = document.getElementById('projectIdInput');
  const btnLoadProject = document.getElementById('btn-load-project');
  let editingNodeId = null;

  // ---------- view transform ----------
  function applyView(){
    board.style.transform = `translate(${state.view.x}px, ${state.view.y}px) scale(${state.view.scale})`;
  }
  applyView();

  // ---------- helpers ----------
  function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function clientToBoard(clientX, clientY){
    const rect = board.getBoundingClientRect();
    const bx = (clientX - rect.left - state.view.x) / state.view.scale;
    const by = (clientY - rect.top - state.view.y) / state.view.scale;
    return { x: bx, y: by };
  }
  function getNode(el){ while(el && el !== document){ if(el.classList && el.classList.contains('node')) return el; el = el.parentNode; } return null; }
  function findNodeById(id){ return state.nodes.find(n => n.id === id); }
  function updateSelectionVisual(){
    state.nodes.forEach(n => n.el.classList.toggle('selected', state.selected === n.id));
  }

  // ---------- create node (supports creating from snapshot) ----------
  // options: { id, addToState=true, skipHistory=false }
  function createNode(x, y, title = 'New', notes = '', options = {}){
    const addToState = options.addToState !== false;
    let id = options.id;
    if(!id){ id = 'n' + (state.nodeId++); } else {
      const m = id.match(/^n(\d+)$/);
      if(m){ state.nodeId = Math.max(state.nodeId, parseInt(m[1],10) + 1); }
    }

    const el = document.createElement('div');
    el.className = 'node'; el.dataset.id = id;
    el.style.left = x + 'px'; el.style.top = y + 'px';
    el.innerHTML = `<div class="title">${escapeHtml(title)}</div><div class="meta">${escapeHtml(notes)}</div><div class="connector" title="Connect"></div>`;
    board.appendChild(el);
    el.style.zIndex = String(1000 + (parseInt(id.replace('n','')) || 0));

    makeDraggable(el);

    const conn = el.querySelector('.connector');
    conn.addEventListener('click', (e)=>{
      e.stopPropagation(); e.preventDefault();
      if(state.connecting){
        if(state.connecting !== id){
          state.links.push({ from: state.connecting, to: id });
          pushHistory(); // connection created
        }
        cancelConnect();
        drawLinks();
        return;
      }
      startConnect(id);
    });

    el.addEventListener('click', (e)=>{ e.stopPropagation(); selectNode(id); });

    el.addEventListener('dblclick', (e)=>{ e.stopPropagation(); openEditModal(id); });

    const nodeObj = { id, el, x, y, title, notes };
    if(addToState) state.nodes.push(nodeObj);
    drawLinks();
    if(addToState && options.skipHistory !== true){
      pushHistory();
    }
    return id;
  }

  // ---------- drag ----------
  function makeDraggable(el){
    let ox=0, oy=0, dragging=false, moved=false;
    let moveHandler, upHandler;
    el.addEventListener('pointerdown', e => {
      if(e.target.classList && e.target.classList.contains('connector')) return;
      e.preventDefault();
      dragging = true; moved = false;
      const rect = board.getBoundingClientRect();
      ox = (e.clientX - rect.left - state.view.x) / state.view.scale - parseFloat(el.style.left || 0);
      oy = (e.clientY - rect.top - state.view.y) / state.view.scale - parseFloat(el.style.top || 0);

      moveHandler = function(ev){
        if(!dragging) return;
        const r = board.getBoundingClientRect();
        const nx = (ev.clientX - r.left - state.view.x) / state.view.scale - ox;
        const ny = (ev.clientY - r.top - state.view.y) / state.view.scale - oy;
        const prevLeft = parseFloat(el.style.left || 0);
        const prevTop = parseFloat(el.style.top || 0);
        if(Math.abs(nx - prevLeft) > 1 || Math.abs(ny - prevTop) > 1) moved = true;
        el.style.left = nx + 'px'; el.style.top = ny + 'px';
        const n = state.nodes.find(it => it.id === el.dataset.id);
        if(n){ n.x = nx; n.y = ny; }
        drawLinks();
      };
      upHandler = function(ev){
        dragging = false;
        document.removeEventListener('pointermove', moveHandler);
        document.removeEventListener('pointerup', upHandler);
        if(moved){
          pushHistory(); // record move as action
        }
      };
      document.addEventListener('pointermove', moveHandler);
      document.addEventListener('pointerup', upHandler);
      try{ el.setPointerCapture && el.setPointerCapture(e.pointerId); }catch(err){}
    });
  }

  // ---------- selection ----------
  function selectNode(id){
    state.selected = id;
    updateSelectionVisual();
  }

  // ---------- connections (preview + finish) ----------
  let previewPath = null;
  function startConnect(id){
    state.connecting = id;
    const src = findNodeById(id);
    if(src) src.el.classList.add('connecting');
    window.addEventListener('mousemove', followMouse);
    window.addEventListener('click', finishConnectOnce);
    window.addEventListener('keydown', onConnectKey);
  }
  function onConnectKey(e){ if(e.key === 'Escape') cancelConnect(); }
  function followMouse(e){
    if(!state.connecting) return;
    const src = findNodeById(state.connecting);
    if(!src) return;
    const b = clientToBoard(e.clientX, e.clientY);
    const x1 = src.x + src.el.offsetWidth;
    const y1 = src.y + src.el.offsetHeight/2;
    const x2 = b.x; const y2 = b.y;
    const dx = Math.max(40, Math.abs(x2-x1)/2);
    if(!previewPath){
      previewPath = document.createElementNS('http://www.w3.org/2000/svg','path');
      previewPath.setAttribute('stroke','#8b5cf6'); previewPath.setAttribute('fill','none');
      previewPath.setAttribute('stroke-width','2'); previewPath.setAttribute('stroke-dasharray','6 6');
      svg.appendChild(previewPath);
    }
    const d = `M ${x1} ${y1} C ${x1+dx} ${y1} ${x2-dx} ${y2} ${x2} ${y2}`;
    previewPath.setAttribute('d', d);
  }
  function finishConnectOnce(e){
    if(!state.connecting) return;
    const target = document.elementFromPoint(e.clientX, e.clientY);
    const nodeEl = getNode(target);
    if(nodeEl && nodeEl.dataset.id !== state.connecting){
      state.links.push({ from: state.connecting, to: nodeEl.dataset.id });
      pushHistory();
    }
    cancelConnect();
    drawLinks();
  }
  function cancelConnect(){
    if(previewPath){ previewPath.remove(); previewPath = null; }
    const src = findNodeById(state.connecting);
    if(src) src.el.classList.remove('connecting');
    window.removeEventListener('mousemove', followMouse);
    window.removeEventListener('click', finishConnectOnce);
    window.removeEventListener('keydown', onConnectKey);
    state.connecting = null;
  }

  // ---------- draw links ----------
  function drawLinks(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    state.links.forEach(l=>{
      const a = findNodeById(l.from);
      const b = findNodeById(l.to);
      if(!a||!b) return;
      const x1 = a.x + a.el.offsetWidth; const y1 = a.y + a.el.offsetHeight/2;
      const x2 = b.x; const y2 = b.y + b.el.offsetHeight/2;
      const dx = Math.max(40, Math.abs(x2-x1)/2);
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M ${x1} ${y1} C ${x1+dx} ${y1} ${x2-dx} ${y2} ${x2} ${y2}`);
      p.setAttribute('stroke','#8b5cf6'); p.setAttribute('fill','none'); p.setAttribute('stroke-width','2');
      svg.appendChild(p);
    });
  }

  // ---------- fit ----------
  function fitAll(padding=80){
    if(state.nodes.length===0) return;
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    state.nodes.forEach(n=>{
      minX=Math.min(minX,n.x); minY=Math.min(minY,n.y);
      maxX=Math.max(maxX,n.x + n.el.offsetWidth); maxY=Math.max(maxY,n.y + n.el.offsetHeight);
    });
    const boardW = Math.max(1, maxX-minX); const boardH = Math.max(1, maxY-minY);
    const wrapRect = wrap.getBoundingClientRect();
    const scale = Math.min((wrapRect.width - padding*2)/boardW, (wrapRect.height - padding*2)/boardH, 1);
    const centerX = (minX + maxX)/2; const centerY = (minY + maxY)/2;
    state.view.scale = Math.max(0.2, scale);
    state.view.x = wrapRect.width/2 - centerX*state.view.scale;
    state.view.y = wrapRect.height/2 - centerY*state.view.scale;
    applyView();
  }

  // ---------- create nodes from inputs ----------
  document.getElementById('btn-create').addEventListener('click', ()=>{
    const rawTitles = document.getElementById('ideaText').value || '';
    const rawBodies = document.getElementById('cardBody').value || '';
    const titles = rawTitles.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const bodies = rawBodies.split(/\r?\n/).map(s=>s.trim());
    if(titles.length===0) return;
    const wrapRect = wrap.getBoundingClientRect();
    const centerBoardX = (wrapRect.width/2 - state.view.x)/state.view.scale;
    const centerBoardY = (wrapRect.height/2 - state.view.y)/state.view.scale;
    let x = Math.max(60, centerBoardX - 60); let y = Math.max(60, centerBoardY - 40);
    titles.forEach((t,i)=>{ createNode(x,y,t,bodies[i]||''); y += 140; });
    drawLinks();
  });

  document.getElementById('btn-workflow').addEventListener('click', ()=>{
    const rawTitles = document.getElementById('ideaText').value || '';
    const rawBodies = document.getElementById('cardBody').value || '';
    const titles = rawTitles.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const bodies = rawBodies.split(/\r?\n/).map(s=>s.trim());
    if(titles.length===0) return;
    const wrapRect = wrap.getBoundingClientRect();
    let startX = Math.max(80, (wrapRect.width/2 - state.view.x)/state.view.scale - (titles.length*170)/2);
    let y = Math.max(120, (wrapRect.height/2 - state.view.y)/state.view.scale - 40);
    const gap = 340; const ids = [];
    titles.forEach((t,i)=>{ ids.push(createNode(startX + i*gap, y, t, bodies[i]||'')); });
    for(let i=1;i<ids.length;i++) state.links.push({ from: ids[i-1], to: ids[i] });
    pushHistory();
    drawLinks();
  });

  // ---------- clear ----------
  document.getElementById('btn-clear').addEventListener('click', ()=>{
    pushHistory();
    state.nodes.forEach(n=>{ if(n.el && n.el.parentNode) n.el.parentNode.removeChild(n.el); });
    state.nodes = []; state.links = []; while(svg.firstChild) svg.removeChild(svg.firstChild);
    state.nodeId=1; state.view={x:0,y:0,scale:1}; applyView();
  });

  // ---------- delete node ----------
  function deleteSelectedNode(){
    const id = state.selected;
    if(!id) return;
    const idx = state.nodes.findIndex(n => n.id === id);
    if(idx === -1) return;
    pushHistory();
    const node = state.nodes[idx];
    if(node.el && node.el.parentNode) node.el.parentNode.removeChild(node.el);
    state.nodes.splice(idx,1);
    state.links = state.links.filter(l => l.from !== id && l.to !== id);
    state.selected = null;
    drawLinks();
  }
  document.getElementById('btn-delete').addEventListener('click', ()=> deleteSelectedNode());

  // Delete + Undo/Redo keys
  window.addEventListener('keydown', e=>{
    if(e.key === 'Delete' || e.key === 'Backspace'){
      if(document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable)) return;
      deleteSelectedNode();
    }
    if((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')){
      e.preventDefault(); undo();
    } else if((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && (e.key === 'Z')) )){
      e.preventDefault(); redo();
    }
  });

  // ---------- undo/redo buttons ----------
  document.getElementById('btn-undo').addEventListener('click', ()=> undo());
  document.getElementById('btn-redo').addEventListener('click', ()=> redo());
  updateUndoRedoButtons();

  // ---------- pan ----------
  let panning=false, sx=0, sy=0;
  wrap.addEventListener('pointerdown', e=>{
    if(getNode(e.target)) return;
    panning=true; sx=e.clientX; sy=e.clientY;
    try{ wrap.setPointerCapture && wrap.setPointerCapture(e.pointerId); }catch(err){}
  });
  window.addEventListener('pointermove', e=>{ if(!panning) return; const dx=e.clientX-sx, dy=e.clientY-sy; sx=e.clientX; sy=e.clientY; state.view.x += dx; state.view.y += dy; applyView(); });
  window.addEventListener('pointerup', e=>{ panning=false; try{ wrap.releasePointerCapture && wrap.releasePointerCapture(e.pointerId);}catch(e){} });

  // ---------- zoom ----------
  wrap.addEventListener('wheel', e=>{
    e.preventDefault();
    const delta = -e.deltaY;
    const factor = 1 + (delta>0?0.08:-0.08);
    const before = clientToBoard(e.clientX, e.clientY);
    state.view.scale = Math.max(0.2, Math.min(3, state.view.scale * factor));
    const afterScreenX = before.x * state.view.scale + state.view.x;
    const afterScreenY = before.y * state.view.scale + state.view.y;
    const rect = board.getBoundingClientRect();
    state.view.x += (e.clientX - rect.left) - afterScreenX;
    state.view.y += (e.clientY - rect.top) - afterScreenY;
    applyView();
  }, { passive:false });

  // ---------- export svg ----------
  document.getElementById('btn-export').addEventListener('click', ()=>{
    const exportSvg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    exportSvg.setAttribute('xmlns','http://www.w3.org/2000/svg');
    if(state.nodes.length===0){
      exportSvg.setAttribute('width', 1200);
      exportSvg.setAttribute('height', 800);
    } else {
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      state.nodes.forEach(n=>{ minX=Math.min(minX,n.x); minY=Math.min(minY,n.y); maxX=Math.max(maxX,n.x + n.el.offsetWidth); maxY=Math.max(maxY,n.y + n.el.offsetHeight); });
      const w = Math.max(800, Math.ceil(maxX - minX + 40));
      const h = Math.max(600, Math.ceil(maxY - minY + 40));
      exportSvg.setAttribute('width', w);
      exportSvg.setAttribute('height', h);
      exportSvg.setAttribute('viewBox', `${minX-20} ${minY-20} ${w} ${h}`);
    }

    state.links.forEach(l=>{
      const a = findNodeById(l.from);
      const b = findNodeById(l.to);
      if(!a||!b) return;
      const x1 = a.x + a.el.offsetWidth; const y1 = a.y + a.el.offsetHeight/2;
      const x2 = b.x; const y2 = b.y + b.el.offsetHeight/2;
      const dx = Math.max(40, Math.abs(x2-x1)/2);
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M ${x1} ${y1} C ${x1+dx} ${y1} ${x2-dx} ${y2} ${x2} ${y2}`);
      p.setAttribute('stroke','#8b5cf6'); p.setAttribute('fill','none'); p.setAttribute('stroke-width','2');
      exportSvg.appendChild(p);
    });

    state.nodes.forEach(n=>{
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      const rx = Math.round(n.x);
      const ry = Math.round(n.y);
      const rw = Math.round(n.el.offsetWidth);
      const rh = Math.round(n.el.offsetHeight);
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('x', rx); rect.setAttribute('y', ry); rect.setAttribute('width', rw); rect.setAttribute('height', rh);
      rect.setAttribute('rx', 10); rect.setAttribute('ry', 10); rect.setAttribute('fill', '#0f1720'); rect.setAttribute('stroke', '#1f2937');

      const title = document.createElementNS('http://www.w3.org/2000/svg','text');
      title.setAttribute('x', rx + 12); title.setAttribute('y', ry + 20); title.setAttribute('font-size', 14); title.setAttribute('fill', '#e6eef8');
      title.textContent = n.title || '';

      const body = document.createElementNS('http://www.w3.org/2000/svg','text');
      body.setAttribute('x', rx + 12); body.setAttribute('y', ry + 40); body.setAttribute('font-size', 12); body.setAttribute('fill', '#90a0b8');
      body.textContent = n.notes || '';

      g.appendChild(rect); g.appendChild(title); g.appendChild(body);
      exportSvg.appendChild(g);
    });

    const s = new XMLSerializer().serializeToString(exportSvg);
    const blob = new Blob([s],{type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='idea-visual.svg'; document.body.appendChild(a);
    a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  // ---------- modal edit ----------
  function openEditModal(id){
    const node = findNodeById(id);
    if(!node) return;
    editingNodeId = id;
    modalTitle.value = node.title || '';
    modalBody.value = node.notes || '';
    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden','false');
    modalTitle.focus();
  }
  function closeModal(){
    editingNodeId = null;
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden','true');
  }
  document.getElementById('modalCancel').addEventListener('click', ()=> closeModal());
  document.getElementById('modalSave').addEventListener('click', ()=>{
    if(!editingNodeId) return;
    const node = findNodeById(editingNodeId);
    if(!node) return;
    pushHistory();
    node.title = modalTitle.value;
    node.notes = modalBody.value;
    node.el.querySelector('.title').innerText = node.title;
    node.el.querySelector('.meta').innerText = node.notes;
    closeModal();
    drawLinks();
  });
  modal.addEventListener('click', e=>{ if(e.target === modal) closeModal(); });

  // ---------- keep svg sized ----------
  function syncSvgSize(){ svg.setAttribute('width', board.offsetWidth); svg.setAttribute('height', board.offsetHeight); }
  window.addEventListener('resize', ()=>{ syncSvgSize(); applyView(); });
  syncSvgSize();

  // ---------- utility: delete node by id (exposed) ----------
  function deleteNodeById(id){
    const idx = state.nodes.findIndex(n => n.id === id);
    if(idx === -1) return;
    const node = state.nodes[idx];
    if(node.el && node.el.parentNode) node.el.parentNode.removeChild(node.el);
    state.nodes.splice(idx, 1);
    state.links = state.links.filter(l => l.from !== id && l.to !== id);
    if(state.selected === id) state.selected = null;
  }

  // ---------- selection when clicking background clears selection ----------
  wrap.addEventListener('click', e=>{ if(getNode(e.target)) return; state.selected = null; updateSelectionVisual(); });

  // ---------- fit button ----------
  document.getElementById('btn-fit').addEventListener('click', ()=> fitAll());

  // ---------- default board for first-time / fallback ----------
  function initializeDefaultBoard(){
    state.nodes.forEach(n=>{ if(n.el && n.el.parentNode) n.el.parentNode.removeChild(n.el); });
    state.nodes = [];
    state.links = [];
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    state.nodeId = 1;
    state.view = { x:0, y:0, scale:1 };
    applyView();
    createNode(220,160,'Central idea','Double-click to edit', { skipHistory: true });
    createNode(520,120,'Branch A','', { skipHistory: true });
    createNode(520,320,'Branch B','', { skipHistory: true });
    history.past = [];
    history.future = [];
    pushHistory(); // initial baseline
    drawLinks();
  }

  // ---------- Project input events ----------
  btnLoadProject.addEventListener('click', ()=>{
    const pid = projectInput.value || '';
    setCurrentProject(pid);
  });
  projectInput.addEventListener('keydown', e=>{
    if(e.key === 'Enter'){
      e.preventDefault();
      btnLoadProject.click();
    }
  });

  // ---------- initial load ----------
  (function initialLoad(){
    let lastId = null;
    try{
      lastId = localStorage.getItem('ideaVisualizerCurrentProjectId');
    }catch(e){}
    if(lastId){
      projectInput.value = lastId;
      currentProjectId = lastId;
      loadFromFirebase(lastId);
    } else {
      initializeDefaultBoard();
    }
  })();

})();
</script>
</body>
</html>
