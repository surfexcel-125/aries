<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Idea Visualizer — Premium Dark (Fixed)</title>
<style>
  :root{--bg:#071019; --card:#0f1720; --muted:#90a0b8; --accent:#8b5cf6; --glass: rgba(255,255,255,0.03);} *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef8;background:linear-gradient(180deg,var(--bg),#041018)}
  header{display:flex;justify-content:space-between;align-items:center;padding:12px 20px;background:#0f1720;border-bottom:1px solid rgba(255,255,255,0.04)}
  h1{margin:0;font-size:16px;color:#e6eef8}
  main{display:flex;gap:20px;padding:20px}
  aside{width:320px;background:#0f1720;border:1px solid rgba(255,255,255,0.06);border-radius:12px;padding:16px}
  label{font-size:13px;color:var(--muted)}
  textarea,input{width:100%;padding:10px;margin-top:6px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04);color:#e6eef8;resize:vertical}
  button{cursor:pointer;border-radius:8px;padding:8px 12px;border:none}
  .btn{background:linear-gradient(90deg,var(--accent),#06b6d4);color:white}

  /* Canvas area */
  #canvasWrap{flex:1;height:600px;border:1px solid rgba(255,255,255,0.03);border-radius:12px;position:relative;background:linear-gradient(180deg,#071019,#041018);overflow:hidden;touch-action:none}
  /* boardArea is transformed; set large virtual size */
  #boardArea{width:4000px;height:2500px;position:absolute;left:0;top:0;transform-origin:0 0}
  .node{position:absolute;min-width:160px;padding:12px;border-radius:10px;color:#e6eef8;background:linear-gradient(180deg,#0f1820,#071117);border:1px solid rgba(255,255,255,0.04);box-shadow:0 18px 40px rgba(2,6,23,0.6);user-select:none}
  .node .title{font-weight:700;margin-bottom:4px}
  .node .meta{font-size:12px;color:var(--muted);white-space:pre-wrap}
  .connector{width:14px;height:14px;border-radius:50%;background:var(--accent);position:absolute;right:8px;top:50%;transform:translateY(-50%);cursor:pointer;box-shadow:0 6px 14px rgba(139,92,246,0.25);border:2px solid rgba(255,255,255,0.06);pointer-events:auto;z-index:20}
  /* SVG matches board coordinates */
  #svgLayer{position:absolute;left:0;top:0;width:4000px;height:2500px;pointer-events:none}

  /* hide native scrollbars if any */
  #canvasWrap::-webkit-scrollbar{display:none}
  #canvasWrap{ -ms-overflow-style: none; scrollbar-width: none; }

  .node.connecting{box-shadow:0 24px 60px rgba(139,92,246,0.35);border-color:rgba(139,92,246,0.6)}
</style>
</head>
<body>
<header>
  <h1>Idea Visualizer — Premium Dark</h1>
  <div style="display:flex;gap:8px">
    <button id="btn-fit" class="btn">Fit</button>
    <button id="btn-export" class="btn">Export SVG</button>
  </div>
</header>
<main>
<aside>
  <label>Card</label>
  <textarea id="ideaText" rows="3" placeholder="Card titles — one per line"></textarea>
  <label style="margin-top:10px">Body (one per line)</label>
  <textarea id="cardBody" rows="5" placeholder="Optional: body text for each node — one per line"></textarea>
  <div style="display:flex;gap:8px;margin-top:10px">
    <button id="btn-create" class="btn">Create Nodes</button>
    <button id="btn-workflow" class="btn">Create Workflow</button>
  </div>
  <button id="btn-clear" style="margin-top:10px">Clear</button>
  <div style="margin-top:12px;color:var(--muted);font-size:13px">Tips: Drag empty background to pan. Use mouse wheel to zoom. Click connector dot then click target node to link. Use <strong>Fit</strong> to center created cards.</div>
</aside>
<div id="canvasWrap">
  <div id="boardArea">
    <svg id="svgLayer" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>
</div>
</main>
<script>
(() => {
  const state = {
    nodes: [], links: [], selected: null, nodeId: 1,
    view: { x: 0, y: 0, scale: 1 },
    connecting: null
  };

  const wrap = document.getElementById('canvasWrap');
  const board = document.getElementById('boardArea');
  const svg = document.getElementById('svgLayer');

  function applyView(){
    board.style.transform = `translate(${state.view.x}px, ${state.view.y}px) scale(${state.view.scale})`;
    // keep svg aligned with board coordinate space (svg is inside board so it inherits transform)
  }
  applyView();

  function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function createNode(x, y, title = 'New', notes = ''){
    const id = 'n' + (state.nodeId++);
    const el = document.createElement('div');
    el.className = 'node'; el.dataset.id = id;
    el.style.left = x + 'px'; el.style.top = y + 'px';
    el.innerHTML = `<div class="title">${escapeHtml(title)}</div><div class="meta">${escapeHtml(notes)}</div><div class="connector" title="Connect"></div>`;
    board.appendChild(el);
    el.style.zIndex = String(state.nodeId * 10);

    // make draggable
    makeDraggable(el);

    const conn = el.querySelector('.connector');
    conn.addEventListener('click', (e)=>{
      e.stopPropagation(); e.preventDefault();
      // click-to-connect: if already connecting, finish connection to this node (click-to-connect)
      if(state.connecting){
        if(state.connecting !== id){
          state.links.push({ from: state.connecting, to: id });
        }
        cancelConnect();
        drawLinks();
        return;
      }
      startConnect(id);
    });

    el.addEventListener('click', (e)=> { e.stopPropagation(); selectNode(id); });

    state.nodes.push({ id, el, x, y, title, notes });
    drawLinks();
    return id;
  }

  function makeDraggable(el){
    let ox=0, oy=0;
    let dragging = false;
    let moveHandler, upHandler;

    el.addEventListener('pointerdown', e => {
      // don't start drag when clicking connector
      if(e.target.classList && e.target.classList.contains('connector')) return;
      e.preventDefault();
      dragging = true;
      const rect = board.getBoundingClientRect();
      ox = (e.clientX - rect.left - state.view.x) / state.view.scale - parseFloat(el.style.left || 0);
      oy = (e.clientY - rect.top - state.view.y) / state.view.scale - parseFloat(el.style.top || 0);

      // attach move/up handlers to document and remove them on pointerup
      moveHandler = function(ev){
        if(!dragging) return;
        const r = board.getBoundingClientRect();
        const nx = (ev.clientX - r.left - state.view.x) / state.view.scale - ox;
        const ny = (ev.clientY - r.top - state.view.y) / state.view.scale - oy;
        el.style.left = nx + 'px'; el.style.top = ny + 'px';
        const n = state.nodes.find(it => it.id === el.dataset.id);
        if(n){ n.x = nx; n.y = ny; }
        drawLinks();
      };
      upHandler = function(){
        dragging = false;
        document.removeEventListener('pointermove', moveHandler);
        document.removeEventListener('pointerup', upHandler);
      };
      document.addEventListener('pointermove', moveHandler);
      document.addEventListener('pointerup', upHandler);

      if(el.setPointerCapture) try{ el.setPointerCapture(e.pointerId); }catch(err){}
    });
  }

  function selectNode(id){ state.selected = id; }

  // Connection logic
  let previewPath = null;

  function startConnect(id){
    state.connecting = id;
    // highlight source node
    const src = state.nodes.find(n=>n.id===id);
    if(src) src.el.classList.add('connecting');

    window.addEventListener('mousemove', followMouse);
    window.addEventListener('click', finishConnectOnce);
    window.addEventListener('keydown', onConnectKey);
  }

  function onConnectKey(e){ if(e.key === 'Escape') { cancelConnect(); } }

  function clientToBoard(clientX, clientY){
    // Convert client coordinates to board (untransformed) coordinates.
    const rect = board.getBoundingClientRect();
    const bx = (clientX - rect.left - state.view.x) / state.view.scale;
    const by = (clientY - rect.top - state.view.y) / state.view.scale;
    return { x: bx, y: by };
  }

  function followMouse(e){
    if(!state.connecting) return;
    const src = state.nodes.find(n=>n.id===state.connecting);
    if(!src) return;
    const b = clientToBoard(e.clientX, e.clientY);
    const x1 = src.x + src.el.offsetWidth;
    const y1 = src.y + src.el.offsetHeight/2;
    const x2 = b.x; const y2 = b.y;
    const dx = Math.max(40, Math.abs(x2-x1)/2);
    if(!previewPath){
      previewPath = document.createElementNS('http://www.w3.org/2000/svg','path');
      previewPath.setAttribute('stroke','#8b5cf6'); previewPath.setAttribute('fill','none');
      previewPath.setAttribute('stroke-width','2'); previewPath.setAttribute('stroke-dasharray','6 6');
      svg.appendChild(previewPath);
    }
    const d = `M ${x1} ${y1} C ${x1+dx} ${y1} ${x2-dx} ${y2} ${x2} ${y2}`;
    previewPath.setAttribute('d', d);
  }

  function finishConnectOnce(e){
    if(!state.connecting) return;
    const target = document.elementFromPoint(e.clientX, e.clientY);
    const nodeEl = getNode(target);
    if(nodeEl && nodeEl.dataset.id !== state.connecting){
      state.links.push({ from: state.connecting, to: nodeEl.dataset.id });
    }
    cancelConnect();
    drawLinks();
  }

  function cancelConnect(){
    if(previewPath){ previewPath.remove(); previewPath = null; }
    const src = state.nodes.find(n=>n.id===state.connecting);
    if(src) src.el.classList.remove('connecting');
    window.removeEventListener('mousemove', followMouse);
    window.removeEventListener('click', finishConnectOnce);
    window.removeEventListener('keydown', onConnectKey);
    state.connecting = null;
  }

  function getNode(el){ while(el && el !== document){ if(el.classList && el.classList.contains('node')) return el; el = el.parentNode; } return null; }

  function drawLinks(){
    // clear existing paths
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    state.links.forEach(l=>{
      const a = state.nodes.find(n=>n.id===l.from);
      const b = state.nodes.find(n=>n.id===l.to);
      if(!a||!b) return;
      const x1 = a.x + a.el.offsetWidth; const y1 = a.y + a.el.offsetHeight/2;
      const x2 = b.x; const y2 = b.y + b.el.offsetHeight/2;
      const dx = Math.max(40, Math.abs(x2-x1)/2);
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M ${x1} ${y1} C ${x1+dx} ${y1} ${x2-dx} ${y2} ${x2} ${y2}`);
      p.setAttribute('stroke','#8b5cf6'); p.setAttribute('fill','none'); p.setAttribute('stroke-width','2');
      svg.appendChild(p);
    });
  }

  // Fit all nodes
  function fitAll(padding=80){
    if(state.nodes.length===0) return;
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    state.nodes.forEach(n=>{
      minX=Math.min(minX,n.x); minY=Math.min(minY,n.y);
      maxX=Math.max(maxX,n.x + n.el.offsetWidth); maxY=Math.max(maxY,n.y + n.el.offsetHeight);
    });
    const boardW = Math.max(1, maxX-minX); const boardH = Math.max(1, maxY-minY);
    const wrapRect = wrap.getBoundingClientRect();
    const scale = Math.min((wrapRect.width - padding*2)/boardW, (wrapRect.height - padding*2)/boardH, 1);
    const centerX = (minX + maxX)/2; const centerY = (minY + maxY)/2;
    state.view.scale = Math.max(0.2, scale);
    state.view.x = wrapRect.width/2 - centerX*state.view.scale;
    state.view.y = wrapRect.height/2 - centerY*state.view.scale;
    applyView();
  }

  // Create nodes from inputs
  document.getElementById('btn-create').addEventListener('click', ()=>{
    const rawTitles = document.getElementById('ideaText').value || '';
    const rawBodies = document.getElementById('cardBody').value || '';
    // correct, robust newline split
    const titles = rawTitles.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const bodies = rawBodies.split(/\r?\n/).map(s=>s.trim());
    if(titles.length===0) return;
    const wrapRect = wrap.getBoundingClientRect();
    const centerBoardX = (wrapRect.width/2 - state.view.x)/state.view.scale;
    const centerBoardY = (wrapRect.height/2 - state.view.y)/state.view.scale;
    let x = Math.max(60, centerBoardX - 60); let y = Math.max(60, centerBoardY - 40);
    titles.forEach((t,i)=>{ createNode(x,y,t,bodies[i]||''); y += 140; });
    drawLinks();
  });

  document.getElementById('btn-workflow').addEventListener('click', ()=>{
    const rawTitles = document.getElementById('ideaText').value || '';
    const rawBodies = document.getElementById('cardBody').value || '';
    const titles = rawTitles.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    const bodies = rawBodies.split(/\r?\n/).map(s=>s.trim());
    if(titles.length===0) return;
    const wrapRect = wrap.getBoundingClientRect();
    let startX = Math.max(80, (wrapRect.width/2 - state.view.x)/state.view.scale - (titles.length*170)/2);
    let y = Math.max(120, (wrapRect.height/2 - state.view.y)/state.view.scale - 40);
    const gap = 340; const ids = [];
    titles.forEach((t,i)=>{ ids.push(createNode(startX + i*gap, y, t, bodies[i]||'')); });
    for(let i=1;i<ids.length;i++) state.links.push({ from: ids[i-1], to: ids[i] });
    drawLinks();
  });

  document.getElementById('btn-clear').addEventListener('click', ()=>{
    state.nodes.forEach(n=>n.el.remove());
    state.nodes = [];
    state.links = [];
    while(svg.firstChild) svg.removeChild(svg.firstChild);
    state.nodeId=1;
    state.view={x:0,y:0,scale:1};
    applyView();
  });

  document.getElementById('btn-fit').addEventListener('click', ()=>{ fitAll(); });

  // Pan: drag empty background (wrap)
  let panning=false, sx=0, sy=0;
  wrap.addEventListener('pointerdown', e=>{
    if(getNode(e.target)) return; // clicked on node
    panning=true; sx=e.clientX; sy=e.clientY;
    try{ wrap.setPointerCapture && wrap.setPointerCapture(e.pointerId); }catch(err){}
  });
  window.addEventListener('pointermove', e=>{ if(!panning) return; const dx=e.clientX-sx, dy=e.clientY-sy; sx=e.clientX; sy=e.clientY; state.view.x += dx; state.view.y += dy; applyView(); });
  window.addEventListener('pointerup', e=>{ panning=false; try{ wrap.releasePointerCapture && wrap.releasePointerCapture(e.pointerId);}catch(e){} });

  // Zoom with wheel (cursor-centered)
  wrap.addEventListener('wheel', e=>{
    e.preventDefault();
    const delta = -e.deltaY;
    const factor = 1 + (delta>0?0.08:-0.08);
    const before = clientToBoard(e.clientX, e.clientY);
    state.view.scale = Math.max(0.2, Math.min(3, state.view.scale * factor));
    const afterScreenX = before.x * state.view.scale + state.view.x;
    const afterScreenY = before.y * state.view.scale + state.view.y;
    const rect = board.getBoundingClientRect();
    state.view.x += (e.clientX - rect.left) - afterScreenX;
    state.view.y += (e.clientY - rect.top) - afterScreenY;
    applyView();
  }, { passive:false });

  // Export SVG (basic - exports links)
  document.getElementById('btn-export').addEventListener('click', ()=>{
    const exportSvg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    exportSvg.setAttribute('xmlns','http://www.w3.org/2000/svg');
    // compute bounding box for export
    if(state.nodes.length===0){
      exportSvg.setAttribute('width', 1200);
      exportSvg.setAttribute('height', 800);
    } else {
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      state.nodes.forEach(n=>{ minX=Math.min(minX,n.x); minY=Math.min(minY,n.y); maxX=Math.max(maxX,n.x + n.el.offsetWidth); maxY=Math.max(maxY,n.y + n.el.offsetHeight); });
      const w = Math.max(800, Math.ceil(maxX - minX + 40));
      const h = Math.max(600, Math.ceil(maxY - minY + 40));
      exportSvg.setAttribute('width', w);
      exportSvg.setAttribute('height', h);
      exportSvg.setAttribute('viewBox', `${minX-20} ${minY-20} ${w} ${h}`);
    }

    state.links.forEach(l=>{
      const a = state.nodes.find(n=>n.id===l.from);
      const b = state.nodes.find(n=>n.id===l.to);
      if(!a||!b) return;
      const x1 = a.x + a.el.offsetWidth; const y1 = a.y + a.el.offsetHeight/2;
      const x2 = b.x; const y2 = b.y + b.el.offsetHeight/2;
      const dx = Math.max(40, Math.abs(x2-x1)/2);
      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M ${x1} ${y1} C ${x1+dx} ${y1} ${x2-dx} ${y2} ${x2} ${y2}`);
      p.setAttribute('stroke','#8b5cf6'); p.setAttribute('fill','none'); p.setAttribute('stroke-width','2');
      exportSvg.appendChild(p);
    });

    // optionally append node rectangles + text if you want; keeping it minimal as before
    const s = new XMLSerializer().serializeToString(exportSvg);
    const blob = new Blob([s],{type:'image/svg+xml'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='idea-visual.svg'; document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });

  // initial sample
  createNode(220,160,'Central idea','Double-click to edit');
  createNode(520,120,'Branch A','');
  createNode(520,320,'Branch B','');
  drawLinks();

  // edit on double click (updates state)
  wrap.addEventListener('dblclick', e=>{
    const nodeEl = getNode(e.target); if(!nodeEl) return;
    const id = nodeEl.dataset.id; const node = state.nodes.find(n=>n.id===id);
    if(!node) return;
    const newTitle = prompt('Edit title', node.title || '');
    if(newTitle!==null){
      node.title = newTitle;
      node.el.querySelector('.title').innerText = newTitle;
    }
    const newBody = prompt('Edit body', node.notes || '');
    if(newBody!==null){
      node.notes = newBody;
      node.el.querySelector('.meta').innerText = newBody;
    }
    drawLinks();
  });

  // keep svg element sized to board (in case you change board size in CSS)
  function syncSvgSize(){
    svg.setAttribute('width', board.offsetWidth);
    svg.setAttribute('height', board.offsetHeight);
  }
  window.addEventListener('resize', ()=>{ syncSvgSize(); applyView(); });
  syncSvgSize();

})();
</script>
</body>
</html>
